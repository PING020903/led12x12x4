C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE GPIO_INIT
OBJECT MODULE PLACED IN .\outputFiles\GPIO_init.obj
COMPILER INVOKED BY: C:\Keil_v4\C51\BIN\C51.EXE source\GPIO_init.c COMPACT BROWSE INCDIR(.\include;.\include) DEBUG OBJE
                    -CTEXTEND LISTINCLUDE PRINT(.\GPIO_init.lst) OBJECT(.\outputFiles\GPIO_init.obj)

line level    source

   1          #include "STC8C.h"
   1      =1  #ifndef     __STC8C_H__
   2      =1  #define     __STC8C_H__
   3      =1  
   4      =1  /////////////////////////////////////////////////
   5      =1  
   6      =1  //"REG51.H"
   7      =1  
   8      =1  sfr         P0          =           0x80;       // PORT 0
   9      =1  sbit        P00         =           P0^0;       // PORT 0 Pin 0
  10      =1  sbit        P01         =           P0^1;       // PORT 0 Pin 1
  11      =1  sbit        P02         =           P0^2;       // PORT 0 Pin 2
  12      =1  sbit        P03         =           P0^3;       // PORT 0 Pin 3
  13      =1  sbit        P04         =           P0^4;       // PORT 0 Pin 4
  14      =1  sbit        P05         =           P0^5;       // PORT 0 Pin 5
  15      =1  sbit        P06         =           P0^6;       // PORT 0 Pin 6
  16      =1  sbit        P07         =           P0^7;       // PORT 0 Pin 7
  17      =1  sfr         SP          =           0x81;
  18      =1  sfr         DPL         =           0x82;
  19      =1  sfr         DPH         =           0x83;
  20      =1  sfr         PCON        =           0x87;       // ÁîµÊ∫êÊéßÂà∂ÂØÑÂ≠òÂô®
  21      =1  sfr         TCON        =           0x88;       // ÂÆöÊó∂Âô®ÊéßÂà∂ÂØÑÂ≠òÂô®
  22      =1  sbit        TF1         =           TCON^7;
  23      =1  sbit        TR1         =           TCON^6;
  24      =1  sbit        TF0         =           TCON^5;
  25      =1  sbit        TR0         =           TCON^4;
  26      =1  sbit        IE1         =           TCON^3;
  27      =1  sbit        IT1         =           TCON^2;
  28      =1  sbit        IE0         =           TCON^1;
  29      =1  sbit        IT0         =           TCON^0;
  30      =1  sfr         TMOD        =           0x89;       // ÂÆöÊó∂Âô®Ê®°ÂºèÂØÑÂ≠òÂô®
  31      =1  sfr         TL0         =           0x8A;       // ÂÆöÊó∂Âô®0(low 8bit)
  32      =1  sfr         TL1         =           0x8B;       // ÂÆöÊó∂Âô®1(low 8bit)
  33      =1  sfr         TH0         =           0x8C;       // ÂÆöÊó∂Âô®0(high 8bit)
  34      =1  sfr         TH1         =           0x8D;       // ÂÆöÊó∂Âô®1(high 8bit)
  35      =1  sfr         AUXR        =           0x8E;       // ËæÖÂä©ÂØÑÂ≠òÂô®1
  36      =1  sfr         INTCLKO     =           0x8F;       // ‰∏≠Êñ≠‰∏éÊó∂ÈíüËæìÂá∫ÊéßÂà∂ÂØÑÂ≠òÂô®
  37      =1  sfr         P1          =           0x90;       // PORT 1
  38      =1  sbit        P10         =           P1^0;       // PORT 1 Pin 0
  39      =1  sbit        P11         =           P1^1;       // PORT 1 Pin 1
  40      =1  sbit        P12         =           P1^2;       // PORT 1 Pin 2
  41      =1  sbit        P13         =           P1^3;       // PORT 1 Pin 3
  42      =1  sbit        P14         =           P1^4;       // PORT 1 Pin 4
  43      =1  sbit        P15         =           P1^5;       // PORT 1 Pin 5
  44      =1  sbit        P16         =           P1^6;       // PORT 1 Pin 6
  45      =1  sbit        P17         =           P1^7;       // PORT 1 Pin 7
  46      =1  sfr         P1M1        =           0x91;       // P1ÈÖçÁΩÆÂØÑÂ≠òÂô®1
  47      =1  sfr         P1M0        =           0x92;       // P1ÈÖçÁΩÆÂØÑÂ≠òÂô®0
  48      =1  sfr         P0M1        =           0x93;       // P0ÈÖçÁΩÆÂØÑÂ≠òÂô®1
  49      =1  sfr         P0M0        =           0x94;       // P0ÈÖçÁΩÆÂØÑÂ≠òÂô®0
  50      =1  sfr         P2M1        =           0x95;       // P2ÈÖçÁΩÆÂØÑÂ≠òÂô®1
  51      =1  sfr         P2M0        =           0x96;       // P2ÈÖçÁΩÆÂØÑÂ≠òÂô®0
  52      =1  sfr         SCON        =           0x98;       // ‰∏≤Âè£1ÊéßÂà∂ÂØÑÂ≠òÂô®
  53      =1  sbit        SM0         =           SCON^7;
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 2   

  54      =1  sbit        SM1         =           SCON^6;
  55      =1  sbit        SM2         =           SCON^5;
  56      =1  sbit        REN         =           SCON^4;     // ‰∏≤Âè£1Êé•Êî∂‰ΩøËÉΩ
  57      =1  sbit        TB8         =           SCON^3;
  58      =1  sbit        RB8         =           SCON^2;
  59      =1  sbit        TI          =           SCON^1;     // ‰∏≤Âè£1ÂèëÈÄÅ‰∏≠Êñ≠ËØ∑Ê±ÇÊ†áÂøó
  60      =1  sbit        RI          =           SCON^0;     // ‰∏≤Âè£1Êé•Êî∂‰∏≠Êñ≠ËØ∑Ê±ÇÊ†áÂøó
  61      =1  sfr         SBUF        =           0x99;       // ‰∏≤Âè£1Êï∞ÊçÆÂØÑÂ≠òÂô®
  62      =1  sfr         S2CON       =           0x9A;       // ‰∏≤Âè£2ÊéßÂà∂ÂØÑÂ≠òÂô®
  63      =1  sfr         S2BUF       =           0x9B;       // ‰∏≤Âè£2Êï∞ÊçÆÂØÑÂ≠òÂô®
  64      =1  sfr         IRCBAND     =           0x9D;
  65      =1  sfr         LIRTRIM     =           0x9E;
  66      =1  sfr         IRTRIM      =           0x9F;
  67      =1  sfr         P2          =           0xA0;       // PORT 2
  68      =1  sbit        P20         =           P2^0;       // PORT 2 Pin 0
  69      =1  sbit        P21         =           P2^1;       // PORT 2 Pin 1
  70      =1  sbit        P22         =           P2^2;       // PORT 2 Pin 2
  71      =1  sbit        P23         =           P2^3;       // PORT 2 Pin 3
  72      =1  sbit        P24         =           P2^4;       // PORT 2 Pin 4
  73      =1  sbit        P25         =           P2^5;       // PORT 2 Pin 5
  74      =1  sbit        P26         =           P2^6;       // PORT 2 Pin 6
  75      =1  sbit        P27         =           P2^7;       // PORT 2 Pin 7
  76      =1  sfr         BUS_SPEED   =           0xA1;
  77      =1  sfr         P_SW1       =           0xA2;
  78      =1  sfr         IE          =           0xA8;       // ‰∏≠Êñ≠ÂÖÅËÆ∏ÂØÑÂ≠òÂô®
  79      =1  sbit        EA          =           IE^7;       // ÊÄª‰∏≠Êñ≠ÂÖÅËÆ∏ÊéßÂà∂‰Ωç
  80      =1  sbit        ELVD        =           IE^6;       // ‰ΩéÁîµÂéãÊ£ÄÊµã‰∏≠Êñ≠ÂÖÅËÆ∏‰Ωç
  81      =1  sbit        EADC        =           IE^5;       
  82      =1  sbit        ES          =           IE^4;       // UART1‰∏≠Êñ≠ÂÖÅËÆ∏‰Ωç
  83      =1  sbit        ET1         =           IE^3;       // timer1‰∏≠Êñ≠ÂÖÅËÆ∏‰Ωç
  84      =1  sbit        EX1         =           IE^2;       // Â§ñÈÉ®‰∏≠Êñ≠1‰∏≠Êñ≠ÂÖÅËÆ∏‰Ωç
  85      =1  sbit        ET0         =           IE^1;       // timer0‰∏≠Êñ≠ÂÖÅËÆ∏‰Ωç
  86      =1  sbit        EX0         =           IE^0;       // Â§ñÈÉ®‰∏≠Êñ≠0‰∏≠Êñ≠ÂÖÅËÆ∏‰Ωç
  87      =1  sfr         SADDR       =           0xA9;       // ‰∏≤Âè£1‰ªéÊú∫Âú∞ÂùÄÂØÑÂ≠òÂô®
  88      =1  sfr         WKTCL       =           0xAA;       // ÊéâÁîµÂî§ÈÜíÂÆöÊó∂Âô®(low 8bit)
  89      =1  sfr         WKTCH       =           0xAB;       // ÊéâÁîµÂî§ÈÜíÂÆöÊó∂Âô®(high 7bit)
  90      =1  sfr         TA          =           0xAE;
  91      =1  sfr         IE2         =           0xAF;       // ‰∏≠Êñ≠ÂÖÅËÆ∏ÂØÑÂ≠òÂô®2
  92      =1  sfr         P3          =           0xB0;       // PORT 3
  93      =1  sbit        P30         =           P3^0;       // PORT 3 Pin 0
  94      =1  sbit        P31         =           P3^1;       // PORT 3 Pin 1
  95      =1  sbit        P32         =           P3^2;       // PORT 3 Pin 2
  96      =1  sbit        P33         =           P3^3;       // PORT 3 Pin 3
  97      =1  sbit        P34         =           P3^4;       // PORT 3 Pin 4
  98      =1  sbit        P35         =           P3^5;       // PORT 3 Pin 5
  99      =1  sbit        P36         =           P3^6;       // PORT 3 Pin 6
 100      =1  sbit        P37         =           P3^7;       // PORT 3 Pin 7
 101      =1  sfr         P3M1        =           0xB1;       // P3ÈÖçÁΩÆÂØÑÂ≠òÂô®1
 102      =1  sfr         P3M0        =           0xB2;       // P3ÈÖçÁΩÆÂØÑÂ≠òÂô®0
 103      =1  sfr         P4M1        =           0xB3;       // P4ÈÖçÁΩÆÂØÑÂ≠òÂô®1
 104      =1  sfr         P4M0        =           0xB4;       // P4ÈÖçÁΩÆÂØÑÂ≠òÂô®0
 105      =1  sfr         IP2         =           0xB5;
 106      =1  sfr         IP2H        =           0xB6;
 107      =1  sfr         IPH         =           0xB7;
 108      =1  sfr         IP          =           0xB8;
 109      =1  sbit        PLVD        =           IP^6;
 110      =1  sbit        PS          =           IP^4;
 111      =1  sbit        PT1         =           IP^3;
 112      =1  sbit        PX1         =           IP^2;
 113      =1  sbit        PT0         =           IP^1;
 114      =1  sbit        PX0         =           IP^0;
 115      =1  sfr         SADEN       =           0xB9;       // ‰∏≤Âè£1‰ªéÊú∫Âú∞ÂùÄÂ±èËîΩÂØÑÂ≠òÂô®
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 3   

 116      =1  sfr         P_SW2       =           0xBA;
 117      =1  sfr         P4          =           0xC0;       // PORT 4
 118      =1  sbit        P40         =           P4^0;       // PORT 4 Pin 0
 119      =1  sbit        P41         =           P4^1;       // PORT 4 Pin 1
 120      =1  sbit        P42         =           P4^2;       // PORT 4 Pin 2
 121      =1  sbit        P43         =           P4^3;       // PORT 4 Pin 3
 122      =1  sbit        P44         =           P4^4;       // PORT 4 Pin 4
 123      =1  sbit        P45         =           P4^5;       // PORT 4 Pin 5
 124      =1  sbit        P46         =           P4^6;       // PORT 4 Pin 6
 125      =1  sbit        P47         =           P4^7;       // PORT 4 Pin 7
 126      =1  sfr         WDT_CONTR   =           0xC1;
 127      =1  sfr         IAP_DATA    =           0xC2;
 128      =1  sfr         IAP_ADDRH   =           0xC3;
 129      =1  sfr         IAP_ADDRL   =           0xC4;
 130      =1  sfr         IAP_CMD     =           0xC5;
 131      =1  sfr         IAP_TRIG    =           0xC6;
 132      =1  sfr         IAP_CONTR   =           0xC7;
 133      =1  sfr         P5          =           0xC8;       // PORT 5
 134      =1  sbit        P50         =           P5^0;       // PORT 5 Pin 0
 135      =1  sbit        P51         =           P5^1;       // PORT 5 Pin 1
 136      =1  sbit        P52         =           P5^2;       // PORT 5 Pin 2
 137      =1  sbit        P53         =           P5^3;       // PORT 5 Pin 3
 138      =1  sbit        P54         =           P5^4;       // PORT 5 Pin 4
 139      =1  sbit        P55         =           P5^5;       // PORT 5 Pin 5
 140      =1  sbit        P56         =           P5^6;       // PORT 5 Pin 6
 141      =1  sbit        P57         =           P5^7;       // PORT 5 Pin 7
 142      =1  sfr         P5M1        =           0xC9;
 143      =1  sfr         P5M0        =           0xCA;
 144      =1  sfr         SPSTAT      =           0xCD;
 145      =1  sfr         SPCTL       =           0xCE;
 146      =1  sfr         SPDAT       =           0xCF;
 147      =1  sfr         PSW         =           0xD0;
 148      =1  sbit        CY          =           PSW^7;
 149      =1  sbit        AC          =           PSW^6;
 150      =1  sbit        F0          =           PSW^5;
 151      =1  sbit        RS1         =           PSW^4;
 152      =1  sbit        RS0         =           PSW^3;
 153      =1  sbit        OV          =           PSW^2;
 154      =1  sbit        F1          =           PSW^1;
 155      =1  sbit        P           =           PSW^0;
 156      =1  sfr         T4T3M       =           0xD1;
 157      =1  sfr         T4H         =           0xD2;
 158      =1  sfr         T4L         =           0xD3;
 159      =1  sfr         T3H         =           0xD4;
 160      =1  sfr         T3L         =           0xD5;
 161      =1  sfr         T2H         =           0xD6;
 162      =1  sfr         T2L         =           0xD7;
 163      =1  sfr         IP3         =           0xDF;
 164      =1  sfr         ACC         =           0xE0;
 165      =1  sfr         DPS         =           0xE3;
 166      =1  sfr         DPL1        =           0xE4;
 167      =1  sfr         DPH1        =           0xE5;
 168      =1  sfr         CMPCR1      =           0xE6;
 169      =1  sfr         CMPCR2      =           0xE7;
 170      =1  sfr         IP3H        =           0xEE;
 171      =1  sfr         AUXINTIF    =           0xEF;
 172      =1  sfr         B           =           0xF0;
 173      =1  sfr         IAP_TPS     =           0xF5;
 174      =1  sfr         RSTCFG      =           0xFF;
 175      =1  
 176      =1  
 177      =1  
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 4   

 178      =1  
 179      =1  //√à√ß√è√Ç√å√ò√ä‚π¶√Ñ‹ºƒ¥√¶√Ü√∑Œª√ì√ö)’πRAM√á√∏√ì√≤
 180      =1  //¬∑√É√é√ä√ï√¢–©¬ºƒ¥√¶√Ü√∑,√ê√®√è»Ω¬´P_SW2¬µ√ÑBIT7√â√®√ñ√ÉŒ™1,¬≤≈ø√â√ï?√Å–¥
 181      =1  
 182      =1  /////////////////////////////////////////////////
 183      =1  //FF00H-FFFFH
 184      =1  /////////////////////////////////////////////////
 185      =1  
 186      =1  
 187      =1  /////////////////////////////////////////////////
 188      =1  //FE00H-FEFFH
 189      =1  /////////////////////////////////////////////////
 190      =1  
 191      =1  
 192      =1  #define     CLKSEL      (*(unsigned char volatile xdata *)0xfe00)   // Êó∂ÈíüÈÄâÊã©ÂØÑÂ≠òÂô®
 193      =1  #define     CLKDIV      (*(unsigned char volatile xdata *)0xfe01)   // Êó∂ÈíüÂàÜÈ¢ëÂØÑÂ≠òÂô®
 194      =1  #define     HIRCCR      (*(unsigned char volatile xdata *)0xfe02)   // È´òÈÄüÊô∂‰ΩìÊåØËç°Âô®Ê†°ÂáÜÂØÑÂ≠òÂô
             -®
 195      =1  #define     XOSCCR      (*(unsigned char volatile xdata *)0xfe03)   // Â§ñÈÉ®ÊåØËç°Âô®Ê†°ÂáÜÂØÑÂ≠òÂô®
 196      =1  #define     IRC32KCR    (*(unsigned char volatile xdata *)0xfe04)   // IRC 32KHz ÊåØËç°Âô®Ê†°ÂáÜÂØÑÂ≠òÂô®
 197      =1  #define     MCLKOCR     (*(unsigned char volatile xdata *)0xfe05)   // ‰∏ªÊó∂ÈíüËæìÂá∫ÊéßÂà∂ÂØÑÂ≠òÂô®
 198      =1  #define     IRCDB       (*(unsigned char volatile xdata *)0xfe06)   // IRC Ë∞ÉËäÇÂØÑÂ≠òÂô®
 199      =1  
 200      =1  // GPIO Á´ØÂè£‰∏äÊãâÁîµÈòªÈÖçÁΩÆÂØÑÂ≠òÂô®
 201      =1  #define     P0PU        (*(unsigned char volatile xdata *)0xfe10)
 202      =1  #define     P1PU        (*(unsigned char volatile xdata *)0xfe11)
 203      =1  #define     P2PU        (*(unsigned char volatile xdata *)0xfe12)
 204      =1  #define     P3PU        (*(unsigned char volatile xdata *)0xfe13)
 205      =1  #define     P4PU        (*(unsigned char volatile xdata *)0xfe14)
 206      =1  #define     P5PU        (*(unsigned char volatile xdata *)0xfe15)
 207      =1  
 208      =1  // GPIO Á´ØÂè£ÊñΩÂØÜÁâπËß¶ÂèëÊéßÂà∂ÂØÑÂ≠òÂô®
 209      =1  #define     P0NCS       (*(unsigned char volatile xdata *)0xfe18)
 210      =1  #define     P1NCS       (*(unsigned char volatile xdata *)0xfe19)
 211      =1  #define     P2NCS       (*(unsigned char volatile xdata *)0xfe1a)
 212      =1  #define     P3NCS       (*(unsigned char volatile xdata *)0xfe1b)
 213      =1  #define     P4NCS       (*(unsigned char volatile xdata *)0xfe1c)
 214      =1  #define     P5NCS       (*(unsigned char volatile xdata *)0xfe1d)
 215      =1  
 216      =1  // GPIO Á´ØÂè£ÁîµÂπ≥ËΩ¨Êç¢ÈÄüÂ∫¶ÊéßÂà∂ÂØÑÂ≠òÂô®
 217      =1  #define     P0SR        (*(unsigned char volatile xdata *)0xfe20)
 218      =1  #define     P1SR        (*(unsigned char volatile xdata *)0xfe21)
 219      =1  #define     P2SR        (*(unsigned char volatile xdata *)0xfe22)
 220      =1  #define     P3SR        (*(unsigned char volatile xdata *)0xfe23)
 221      =1  #define     P4SR        (*(unsigned char volatile xdata *)0xfe24)
 222      =1  #define     P5SR        (*(unsigned char volatile xdata *)0xfe25)
 223      =1  
 224      =1  // GPIO Á´ØÂè£ÁîµÊµÅÊéßÂà∂ÂØÑÂ≠òÂô®
 225      =1  #define     P0DR        (*(unsigned char volatile xdata *)0xfe28)
 226      =1  #define     P1DR        (*(unsigned char volatile xdata *)0xfe29)
 227      =1  #define     P2DR        (*(unsigned char volatile xdata *)0xfe2a)
 228      =1  #define     P3DR        (*(unsigned char volatile xdata *)0xfe2b)
 229      =1  #define     P4DR        (*(unsigned char volatile xdata *)0xfe2c)
 230      =1  #define     P5DR        (*(unsigned char volatile xdata *)0xfe2d)
 231      =1  
 232      =1  // GPIO Á´ØÂè£‰∏≠Êñ≠‰ΩøËÉΩÂØÑÂ≠òÂô®
 233      =1  #define     P0IE        (*(unsigned char volatile xdata *)0xfe30)
 234      =1  #define     P1IE        (*(unsigned char volatile xdata *)0xfe31)
 235      =1  
 236      =1  // I2C ÈÖçÁΩÆÂíåÊéßÂà∂ÂØÑÂ≠òÂô®
 237      =1  #define     I2CCFG      (*(unsigned char volatile xdata *)0xfe80)
 238      =1  #define     I2CMSCR     (*(unsigned char volatile xdata *)0xfe81)
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 5   

 239      =1  #define     I2CMSST     (*(unsigned char volatile xdata *)0xfe82)
 240      =1  #define     I2CSLCR     (*(unsigned char volatile xdata *)0xfe83)
 241      =1  #define     I2CSLST     (*(unsigned char volatile xdata *)0xfe84)
 242      =1  #define     I2CSLADR    (*(unsigned char volatile xdata *)0xfe85)
 243      =1  #define     I2CTXD      (*(unsigned char volatile xdata *)0xfe86)
 244      =1  #define     I2CRXD      (*(unsigned char volatile xdata *)0xfe87)
 245      =1  #define     I2CMSAUX    (*(unsigned char volatile xdata *)0xfe88)
 246      =1  
 247      =1  // ÂÆöÊó∂Âô®È¢ÑÂàÜÈ¢ëÂØÑÂ≠òÂô®
 248      =1  #define     TM2PS       (*(unsigned char volatile xdata *)0xfea2)
 249      =1  #define     TM3PS       (*(unsigned char volatile xdata *)0xfea3)
 250      =1  #define     TM4PS       (*(unsigned char volatile xdata *)0xfea4)
 251      =1  
 252      =1  /////////////////////////////////////////////////
 253      =1  //FD00H-FDFFH
 254      =1  /////////////////////////////////////////////////
 255      =1  
 256      =1  // GPIO Á´ØÂè£‰∏≠Êñ≠‰ΩøËÉΩÂØÑÂ≠òÂô®
 257      =1  #define     P0INTE      (*(unsigned char volatile xdata *)0xfd00)
 258      =1  #define     P1INTE      (*(unsigned char volatile xdata *)0xfd01)
 259      =1  #define     P2INTE      (*(unsigned char volatile xdata *)0xfd02)
 260      =1  #define     P3INTE      (*(unsigned char volatile xdata *)0xfd03)
 261      =1  #define     P4INTE      (*(unsigned char volatile xdata *)0xfd04)
 262      =1  #define     P5INTE      (*(unsigned char volatile xdata *)0xfd05)
 263      =1  
 264      =1  // GPIO Á´ØÂè£‰∏≠Êñ≠Ê†áÂøóÂØÑÂ≠òÂô®
 265      =1  #define     P0INTF      (*(unsigned char volatile xdata *)0xfd10)
 266      =1  #define     P1INTF      (*(unsigned char volatile xdata *)0xfd11)
 267      =1  #define     P2INTF      (*(unsigned char volatile xdata *)0xfd12)
 268      =1  #define     P3INTF      (*(unsigned char volatile xdata *)0xfd13)
 269      =1  #define     P4INTF      (*(unsigned char volatile xdata *)0xfd14)
 270      =1  #define     P5INTF      (*(unsigned char volatile xdata *)0xfd15)
 271      =1  
 272      =1  // GPIO Á´ØÂè£‰∏≠Êñ≠Ê®°Âºè0ÂØÑÂ≠òÂô®
 273      =1  #define     P0IM0       (*(unsigned char volatile xdata *)0xfd20)
 274      =1  #define     P1IM0       (*(unsigned char volatile xdata *)0xfd21)
 275      =1  #define     P2IM0       (*(unsigned char volatile xdata *)0xfd22)
 276      =1  #define     P3IM0       (*(unsigned char volatile xdata *)0xfd23)
 277      =1  #define     P4IM0       (*(unsigned char volatile xdata *)0xfd24)
 278      =1  #define     P5IM0       (*(unsigned char volatile xdata *)0xfd25)
 279      =1  
 280      =1  // GPIO Á´ØÂè£‰∏≠Êñ≠Ê®°Âºè1ÂØÑÂ≠òÂô®
 281      =1  #define     P0IM1       (*(unsigned char volatile xdata *)0xfd30)
 282      =1  #define     P1IM1       (*(unsigned char volatile xdata *)0xfd31)
 283      =1  #define     P2IM1       (*(unsigned char volatile xdata *)0xfd32)
 284      =1  #define     P3IM1       (*(unsigned char volatile xdata *)0xfd33)
 285      =1  #define     P4IM1       (*(unsigned char volatile xdata *)0xfd34)
 286      =1  #define     P5IM1       (*(unsigned char volatile xdata *)0xfd35)
 287      =1  
 288      =1  /////////////////////////////////////////////////
 289      =1  //FC00H-FCFFH
 290      =1  /////////////////////////////////////////////////
 291      =1  
 292      =1  // Â§öË∑ØÂ§çÁî®Êï∞Â≠óËæìÂÖ•Á´ØÂè£ÂØÑÂ≠òÂô®
 293      =1  #define     MD3         (*(unsigned char volatile xdata *)0xfcf0)
 294      =1  #define     MD2         (*(unsigned char volatile xdata *)0xfcf1)
 295      =1  #define     MD1         (*(unsigned char volatile xdata *)0xfcf2)
 296      =1  #define     MD0         (*(unsigned char volatile xdata *)0xfcf3)
 297      =1  #define     MD5         (*(unsigned char volatile xdata *)0xfcf4)
 298      =1  #define     MD4         (*(unsigned char volatile xdata *)0xfcf5)
 299      =1  
 300      =1  // Ê®°ÊãüÂ§çÁî®Âô®ÊéßÂà∂ÂíåADCÊéßÂà∂ÂØÑÂ≠òÂô®
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 6   

 301      =1  #define     ARCON       (*(unsigned char volatile xdata *)0xfcf6)
 302      =1  #define     OPCON       (*(unsigned char volatile xdata *)0xfcf7)
 303      =1  
 304      =1  /////////////////////////////////////////////////
 305      =1  //FB00H-FBFFH
 306      =1  /////////////////////////////////////////////////
 307      =1  
 308      =1  
 309      =1  /////////////////////////////////////////////////
 310      =1  //FA00H-FAFFH
 311      =1  /////////////////////////////////////////////////
 312      =1  
 313      =1  
 314      =1  /////////////////////////////////////////////////
 315      =1  
 316      =1  #endif
 317      =1  
   2          #include "stdio.h"
   1      =1  /*--------------------------------------------------------------------------
   2      =1  STDIO.H
   3      =1  
   4      =1  Prototypes for standard I/O functions.
   5      =1  Copyright (c) 1988-2002 Keil Elektronik GmbH and Keil Software, Inc.
   6      =1  All rights reserved.
   7      =1  --------------------------------------------------------------------------*/
   8      =1  
   9      =1  #ifndef __STDIO_H__
  10      =1  #define __STDIO_H__
  11      =1  
  12      =1  #ifndef EOF
  13      =1   #define EOF -1
  14      =1  #endif
  15      =1  
  16      =1  #ifndef NULL
  17      =1   #define NULL ((void *) 0)
  18      =1  #endif
  19      =1  
  20      =1  #ifndef _SIZE_T
  21      =1   #define _SIZE_T
  22      =1   typedef unsigned int size_t;
  23      =1  #endif
  24      =1  
  25      =1  #pragma SAVE
  26      =1  #pragma REGPARMS
  27      =1  extern char _getkey (void);
  28      =1  extern char getchar (void);
  29      =1  extern char ungetchar (char);
  30      =1  extern char putchar (char);
  31      =1  extern int printf   (const char *, ...);
  32      =1  extern int sprintf  (char *, const char *, ...);
  33      =1  extern int vprintf  (const char *, char *);
  34      =1  extern int vsprintf (char *, const char *, char *);
  35      =1  extern char *gets (char *, int n);
  36      =1  extern int scanf (const char *, ...);
  37      =1  extern int sscanf (char *, const char *, ...);
  38      =1  extern int puts (const char *);
  39      =1  
  40      =1  #pragma RESTORE
  41      =1  
  42      =1  #endif
  43      =1  
   3          #include "GPIO_init.h"
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 7   

   1      =1  #ifndef _GPIO_INIT_H_
   2      =1  #define _GPIO_INIT_H_
   3      =1  
   4      =1  #define BIT_SET_ZERO(src, cnt) src &= ~(1 << cnt) // Áªô src Â∑¶Áßª cnt‰ΩçÂÜô0
   5      =1  #define BIT_SET_ONE(src, cnt) src |= (1 << cnt) // Áªô src Â∑¶Áßª cnt ‰ΩçÂÜô1
   6      =1  #define FIND_BIT(src, cnt) (src & (1 << cnt)) // Êâæ src ‰∏≠Â∑¶Áßª cnt ‰ΩçÁöÑ 1
   7      =1  
   8      =1  #define SEVENTH_BIT 7
   9      =1  #define SIXTH_BIT 6
  10      =1  #define FIFTH_BIT 5
  11      =1  #define FOURTH_BIT 4
  12      =1  #define THIRD_BIT 3
  13      =1  #define SECOND_BIT 2
  14      =1  #define FIRST_BIT 1
  15      =1  #define ZEROTH_BIT 0
  16      =1  #define NEXT_CH_BIT 8
  17      =1  
  18      =1  #define LOW_FREQUENCY !1
  19      =1  #define TIMER_MAX_COUNT (65535U)
  20      =1  #define BAUD_RATE (115200U)
  21      =1  #if LOW_FREQUENCY
           =1 #define FOSC 11059200UL
           =1 #else
  24      =1  #define FOSC 33177200UL
  25      =1  #endif
  26      =1  #define BRT ((TIMER_MAX_COUNT + 1U) - (FOSC / BAUD_RATE / 4U))
  27      =1  
  28      =1  #ifndef USE_P0
  29      =1  #define USE_P0 (unsigned char)(0x0f) // P0ÊâÄ‰ΩøÁî®ÁöÑ pin
  30      =1  #endif // !USE_P0
  31      =1  
  32      =1  #ifndef USER_P1
  33      =1  #define USE_P1 (unsigned char)(0xFF) // P1ÊâÄ‰ΩøÁî®ÁöÑ pin
  34      =1  #endif // !USER_P1
  35      =1  
  36      =1  #ifndef USE_P2
  37      =1  #define USE_P2 (unsigned char)(0xFF) // P2ÊâÄ‰ΩøÁî®ÁöÑ pin
  38      =1  #endif // !USE_P2
  39      =1  
  40      =1  #ifndef USE_P3
  41      =1  #define USE_P3 (unsigned char)(0xf8) // P3ÊâÄ‰ΩøÁî®ÁöÑ pin
  42      =1  #endif // !USE_P3
  43      =1  
  44      =1  #define MIN_BYTES (2)
  45      =1  #define MIN_ARR_LEN (12)
  46      =1  
  47      =1  
  48      =1  
  49      =1  void GPIO_setPushPullupOutput(const unsigned char port, const unsigned char pin);
  50      =1  
  51      =1  void GPIO_setOpenDrainOutput(const unsigned char port, const unsigned char pin);
  52      =1  
  53      =1  void GPIO_setStandardBidirectional(const unsigned char port, const unsigned char pin);
  54      =1  
  55      =1  void GPIO_setHighResistanceInput(const unsigned char port, const unsigned char pin);
  56      =1  
  57      =1  void GPIO_setPullup(const unsigned char port,
  58      =1                      const unsigned char pin,
  59      =1                      const unsigned char en);
  60      =1  
  61      =1  void GPIO_setSchmidtTrigger(const unsigned char port,
  62      =1                              const unsigned char pin,
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 8   

  63      =1                              const unsigned char en);
  64      =1  
  65      =1  void GPIO_setLevelShiftingSpeed(const unsigned char port,
  66      =1                                  const unsigned char pin,
  67      =1                                  const unsigned char en);
  68      =1  
  69      =1  void GPIO_setDriveCurrent(const unsigned char port,
  70      =1                            const unsigned char pin,
  71      =1                            const unsigned char en);
  72      =1  
  73      =1  void UartInit(void);
  74      =1  
  75      =1  void UartSendByte(unsigned char ch);
  76      =1  
  77      =1  void UartSendString(const char* str);
  78      =1  
  79      =1  void GPIO_init(void);
  80      =1  
  81      =1  void LED_off(void);
  82      =1  
  83      =1  void LED_allON(unsigned char LED_line);
  84      =1  
  85      =1  void LED_allON_test(void);
  86      =1  
  87      =1  void LED_leftON_test(void);
  88      =1  
  89      =1  void LED_rightON_test(void);
  90      =1  
  91      =1  void LED_twoBytes_test(void);
  92      =1  
  93      =1  void LED_twoBytes_test1(void);
  94      =1  
  95      =1  void LED_twoBytes_test2(void);
  96      =1  
  97      =1  void LED_twoBytes_test3(void);
  98      =1  
  99      =1  void LED_screen0_test(const unsigned char(*strData)[12],
 100      =1                        const unsigned char bytes,
 101      =1                        const unsigned char arrLen);
 102      =1  
 103      =1  void LED_screen1_test(const unsigned char(*strData)[12],
 104      =1                       const unsigned char bytes,
 105      =1                       const unsigned char arrLen);
 106      =1  
 107      =1  void LED_screen2_test(const unsigned char(*strData)[12],
 108      =1                        const unsigned char bytes,
 109      =1                        const unsigned char arrLen);
 110      =1  
 111      =1  void LED_screen3_test(const unsigned char(*strData)[12],
 112      =1                        const unsigned char bytes,
 113      =1                        const unsigned char arrLen);
 114      =1  
 115      =1  #endif  // _GPIO_INIT_H_
   4          
   5          #define PORT_RESET (unsigned char)(0XFF)
   6          #define IO_M0_RESET (unsigned char)(0x00)
   7          #define IO_M1_RESET (unsigned char)(0x00)
   8          #define IO_SPEED_RESET (unsigned char)(0XFF)
   9          #define IO_TURBO_RESET (unsigned char)(0XFF)
  10          
  11          #define DEBUG_INTO_STACK 1
  12          #define SREEN_DEBUG 0
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 9   

  13          #define LED_DEBUG 1
  14          
  15          #define CONFIG_DEBUG 0
  16          
  17          static bit busy;  // ÂèëÈÄÅÁºìÂÜ≤Âå∫ÊòØÂê¶Âøô
  18          static char wptr; // ÂÜôÊåáÈíà
  19          static char rptr; // ËØªÊåáÈíà
  20          static char buffer[16];
  21          
  22          // UART1‰∏≠Êñ≠ÊúçÂä°Á®ãÂ∫è, ‰∏≠Êñ≠Á≠âÁ∫ß4
  23          static void UartIsr(void) interrupt 4
  24          {
  25   1          if ( TI )
  26   1          {
  27   2              TI = 0;
  28   2              busy = 0;
  29   2          }
  30   1          if ( RI )
  31   1          {
  32   2              RI = 0;
  33   2              buffer[wptr++] = SBUF;
  34   2              wptr &= 0x0f;
  35   2          }
  36   1      }
  37          
  38          /// @brief ËÆæÁΩÆÊé®ÊåΩËæìÂá∫
  39          /// @param port Á´ØÂè£
  40          /// @param pin ÂºïËÑö
  41          void GPIO_setPushPullupOutput(const unsigned char port, const unsigned char pin)
  42          {
  43   1          unsigned char fr_M0 = IO_M0_RESET;
  44   1          unsigned char fr_M1 = IO_M1_RESET;
  45   1          if ( port > 5 || pin > 7 )
  46   1              return;
  47   1      
  48   1          switch ( port ) // Ê†πÊçÆ portËØªÂèñ‰∏çÂêåÁöÑÂØÑÂ≠òÂô®
  49   1          {
  50   2              case 0:
  51   2                  fr_M0 = P0M0;
  52   2                  fr_M1 = P0M1;
  53   2                  break;
  54   2              case 1:
  55   2                  fr_M0 = P1M0;
  56   2                  fr_M1 = P1M1;
  57   2                  break;
  58   2              case 2:
  59   2                  fr_M0 = P2M0;
  60   2                  fr_M1 = P2M1;
  61   2                  break;
  62   2              case 3:
  63   2                  fr_M0 = P3M0;
  64   2                  fr_M1 = P3M1;
  65   2                  break;
  66   2              case 4:
  67   2                  fr_M0 = P4M0;
  68   2                  fr_M1 = P4M1;
  69   2                  break;
  70   2              case 5:
  71   2                  fr_M0 = P5M0;
  72   2                  fr_M1 = P5M1;
  73   2                  break;
  74   2              default:
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 10  

  75   2                  return;
  76   2          }
  77   1          BIT_SET_ONE(fr_M0, pin);
  78   1          BIT_SET_ZERO(fr_M1, pin);
  79   1      
  80   1          switch ( port ) // Ê†πÊçÆ portËØªÂèñ‰∏çÂêåÁöÑÂØÑÂ≠òÂô®
  81   1          {
  82   2              case 0:
  83   2                  P0M0 = fr_M0;
  84   2                  P0M1 = fr_M1;
  85   2                  break;
  86   2              case 1:
  87   2                  P1M0 = fr_M0;
  88   2                  P1M1 = fr_M1;
  89   2                  break;
  90   2              case 2:
  91   2                  P2M0 = fr_M0;
  92   2                  P2M1 = fr_M1;
  93   2                  break;
  94   2              case 3:
  95   2                  P3M0 = fr_M0;
  96   2                  P3M1 = fr_M1;
  97   2                  break;
  98   2              case 4:
  99   2                  P4M0 = fr_M0;
 100   2                  P4M1 = fr_M1;
 101   2                  break;
 102   2              case 5:
 103   2                  P5M0 = fr_M0;
 104   2                  P5M1 = fr_M1;
 105   2                  break;
 106   2              default:
 107   2                  return;
 108   2          }
 109   1          return;
 110   1      }
 111          
 112          /// @brief ËÆæÁΩÆÂºÄÊºèËæìÂá∫
 113          /// @param port Á´ØÂè£
 114          /// @param pin ÂºïËÑö
 115          void GPIO_setOpenDrainOutput(const unsigned char port, const unsigned char pin)
 116          {
 117   1          unsigned char fr_M0 = IO_M0_RESET;
 118   1          unsigned char fr_M1 = IO_M1_RESET;
 119   1          if ( port > 5 || pin > 7 )
 120   1              return;
 121   1      
 122   1          switch ( port ) // Ê†πÊçÆ portËØªÂèñ‰∏çÂêåÁöÑÂØÑÂ≠òÂô®
 123   1          {
 124   2              case 0:
 125   2                  fr_M0 = P0M0;
 126   2                  fr_M1 = P0M1;
 127   2                  break;
 128   2              case 1:
 129   2                  fr_M0 = P1M0;
 130   2                  fr_M1 = P1M1;
 131   2                  break;
 132   2              case 2:
 133   2                  fr_M0 = P2M0;
 134   2                  fr_M1 = P2M1;
 135   2                  break;
 136   2              case 3:
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 11  

 137   2                  fr_M0 = P3M0;
 138   2                  fr_M1 = P3M1;
 139   2                  break;
 140   2              case 4:
 141   2                  fr_M0 = P4M0;
 142   2                  fr_M1 = P4M1;
 143   2                  break;
 144   2              case 5:
 145   2                  fr_M0 = P5M0;
 146   2                  fr_M1 = P5M1;
 147   2                  break;
 148   2              default:
 149   2                  return;
 150   2          }
 151   1          BIT_SET_ONE(fr_M0, pin);
 152   1          BIT_SET_ONE(fr_M1, pin);
 153   1      
 154   1          switch ( port ) // Ê†πÊçÆ portËØªÂèñ‰∏çÂêåÁöÑÂØÑÂ≠òÂô®
 155   1          {
 156   2              case 0:
 157   2                  P0M0 = fr_M0;
 158   2                  P0M1 = fr_M1;
 159   2                  break;
 160   2              case 1:
 161   2                  P1M0 = fr_M0;
 162   2                  P1M1 = fr_M1;
 163   2                  break;
 164   2              case 2:
 165   2                  P2M0 = fr_M0;
 166   2                  P2M1 = fr_M1;
 167   2                  break;
 168   2              case 3:
 169   2                  P3M0 = fr_M0;
 170   2                  P3M1 = fr_M1;
 171   2                  break;
 172   2              case 4:
 173   2                  P4M0 = fr_M0;
 174   2                  P4M1 = fr_M1;
 175   2                  break;
 176   2              case 5:
 177   2                  P5M0 = fr_M0;
 178   2                  P5M1 = fr_M1;
 179   2                  break;
 180   2              default:
 181   2                  return;
 182   2          }
 183   1          return;
 184   1      }
 185          
 186          /// @brief ËÆæÁΩÆÊ†áÂáÜÂèåÂêëÊ®°Âºè
 187          /// @param port
 188          /// @param pin
 189          void GPIO_setStandardBidirectional(const unsigned char port, const unsigned char pin)
 190          {
 191   1          unsigned char fr_M0 = IO_M0_RESET;
 192   1          unsigned char fr_M1 = IO_M1_RESET;
 193   1          if ( port > 5 || pin > 7 )
 194   1              return;
 195   1      
 196   1          switch ( port ) // Ê†πÊçÆ portËØªÂèñ‰∏çÂêåÁöÑÂØÑÂ≠òÂô®
 197   1          {
 198   2              case 0:
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 12  

 199   2                  fr_M0 = P0M0;
 200   2                  fr_M1 = P0M1;
 201   2                  break;
 202   2              case 1:
 203   2                  fr_M0 = P1M0;
 204   2                  fr_M1 = P1M1;
 205   2                  break;
 206   2              case 2:
 207   2                  fr_M0 = P2M0;
 208   2                  fr_M1 = P2M1;
 209   2                  break;
 210   2              case 3:
 211   2                  fr_M0 = P3M0;
 212   2                  fr_M1 = P3M1;
 213   2                  break;
 214   2              case 4:
 215   2                  fr_M0 = P4M0;
 216   2                  fr_M1 = P4M1;
 217   2                  break;
 218   2              case 5:
 219   2                  fr_M0 = P5M0;
 220   2                  fr_M1 = P5M1;
 221   2                  break;
 222   2              default:
 223   2                  return;
 224   2          }
 225   1          BIT_SET_ZERO(fr_M0, pin);
 226   1          BIT_SET_ZERO(fr_M1, pin);
 227   1      
 228   1          switch ( port ) // Ê†πÊçÆ portËØªÂèñ‰∏çÂêåÁöÑÂØÑÂ≠òÂô®
 229   1          {
 230   2              case 0:
 231   2                  P0M0 = fr_M0;
 232   2                  P0M1 = fr_M1;
 233   2                  break;
 234   2              case 1:
 235   2                  P1M0 = fr_M0;
 236   2                  P1M1 = fr_M1;
 237   2                  break;
 238   2              case 2:
 239   2                  P2M0 = fr_M0;
 240   2                  P2M1 = fr_M1;
 241   2                  break;
 242   2              case 3:
 243   2                  P3M0 = fr_M0;
 244   2                  P3M1 = fr_M1;
 245   2                  break;
 246   2              case 4:
 247   2                  P4M0 = fr_M0;
 248   2                  P4M1 = fr_M1;
 249   2                  break;
 250   2              case 5:
 251   2                  P5M0 = fr_M0;
 252   2                  P5M1 = fr_M1;
 253   2                  break;
 254   2              default:
 255   2                  return;
 256   2          }
 257   1          return;
 258   1      }
 259          
 260          /// @brief ËÆæÁΩÆÈ´òÈòªËæìÂÖ•
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 13  

 261          /// @param port
 262          /// @param pin
 263          void GPIO_setHighResistanceInput(const unsigned char port, const unsigned char pin)
 264          {
 265   1          unsigned char fr_M0 = IO_M0_RESET;
 266   1          unsigned char fr_M1 = IO_M1_RESET;
 267   1          if ( port > 5 || pin > 7 )
 268   1              return;
 269   1      
 270   1          switch ( port ) // Ê†πÊçÆ portËØªÂèñ‰∏çÂêåÁöÑÂØÑÂ≠òÂô®
 271   1          {
 272   2              case 0:
 273   2                  fr_M0 = P0M0;
 274   2                  fr_M1 = P0M1;
 275   2                  break;
 276   2              case 1:
 277   2                  fr_M0 = P1M0;
 278   2                  fr_M1 = P1M1;
 279   2                  break;
 280   2              case 2:
 281   2                  fr_M0 = P2M0;
 282   2                  fr_M1 = P2M1;
 283   2                  break;
 284   2              case 3:
 285   2                  fr_M0 = P3M0;
 286   2                  fr_M1 = P3M1;
 287   2                  break;
 288   2              case 4:
 289   2                  fr_M0 = P4M0;
 290   2                  fr_M1 = P4M1;
 291   2                  break;
 292   2              case 5:
 293   2                  fr_M0 = P5M0;
 294   2                  fr_M1 = P5M1;
 295   2                  break;
 296   2              default:
 297   2                  return;
 298   2          }
 299   1          BIT_SET_ZERO(fr_M0, pin);
 300   1          BIT_SET_ONE(fr_M1, pin);
 301   1      
 302   1          switch ( port ) // Ê†πÊçÆ portËØªÂèñ‰∏çÂêåÁöÑÂØÑÂ≠òÂô®
 303   1          {
 304   2              case 0:
 305   2                  P0M0 = fr_M0;
 306   2                  P0M1 = fr_M1;
 307   2                  break;
 308   2              case 1:
 309   2                  P1M0 = fr_M0;
 310   2                  P1M1 = fr_M1;
 311   2                  break;
 312   2              case 2:
 313   2                  P2M0 = fr_M0;
 314   2                  P2M1 = fr_M1;
 315   2                  break;
 316   2              case 3:
 317   2                  P3M0 = fr_M0;
 318   2                  P3M1 = fr_M1;
 319   2                  break;
 320   2              case 4:
 321   2                  P4M0 = fr_M0;
 322   2                  P4M1 = fr_M1;
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 14  

 323   2                  break;
 324   2              case 5:
 325   2                  P5M0 = fr_M0;
 326   2                  P5M1 = fr_M1;
 327   2                  break;
 328   2              default:
 329   2                  return;
 330   2          }
 331   1          return;
 332   1      }
 333          
 334          /// @brief ËÆæÁΩÆ‰∏äÊãâÁîµÈòª
 335          /// @param port Á´ØÂè£
 336          /// @param pin ÂºïËÑö
 337          /// @param en 0 ÂÖ≥Èó≠, 1 ÊâìÂºÄ
 338          void GPIO_setPullup(const unsigned char port,
 339                              const unsigned char pin,
 340                              const unsigned char en)
 341          {
 342   1          unsigned char fr_status;
 343   1          switch ( en )
 344   1          {
 345   2              case 0:
 346   2                  switch ( port )
 347   2                  {
 348   3                      case 0:
 349   3                          fr_status = P0PU;
 350   3                          BIT_SET_ZERO(fr_status, pin);
 351   3                          P0PU = fr_status;
 352   3                          break;
 353   3                      case 1:
 354   3                          fr_status = P1PU;
 355   3                          BIT_SET_ZERO(fr_status, pin);
 356   3                          P1PU = fr_status;
 357   3                          break;
 358   3                      case 2:
 359   3                          fr_status = P2PU;
 360   3                          BIT_SET_ZERO(fr_status, pin);
 361   3                          P2PU = fr_status;
 362   3                          break;
 363   3                      case 3:
 364   3                          fr_status = P3PU;
 365   3                          BIT_SET_ZERO(fr_status, pin);
 366   3                          P3PU = fr_status;
 367   3                          break;
 368   3                      case 4:
 369   3                          fr_status = P4PU;
 370   3                          BIT_SET_ZERO(fr_status, pin);
 371   3                          P4PU = fr_status;
 372   3                          break;
 373   3                      case 5:
 374   3                          fr_status = P5PU;
 375   3                          BIT_SET_ZERO(fr_status, pin);
 376   3                          P5PU = fr_status;
 377   3                          break;
 378   3                      default:
 379   3                          break;
 380   3                  }
 381   2              default:
 382   2                  switch ( port )
 383   2                  {
 384   3                      case 0:
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 15  

 385   3                          fr_status = P0PU;
 386   3                          BIT_SET_ONE(fr_status, pin);
 387   3                          P0PU = fr_status;
 388   3                          break;
 389   3                      case 1:
 390   3                          fr_status = P1PU;
 391   3                          BIT_SET_ONE(fr_status, pin);
 392   3                          P1PU = fr_status;
 393   3                          break;
 394   3                      case 2:
 395   3                          fr_status = P2PU;
 396   3                          BIT_SET_ONE(fr_status, pin);
 397   3                          P2PU = fr_status;
 398   3                          break;
 399   3                      case 3:
 400   3                          fr_status = P3PU;
 401   3                          BIT_SET_ONE(fr_status, pin);
 402   3                          P3PU = fr_status;
 403   3                          break;
 404   3                      case 4:
 405   3                          fr_status = P4PU;
 406   3                          BIT_SET_ONE(fr_status, pin);
 407   3                          P4PU = fr_status;
 408   3                          break;
 409   3                      case 5:
 410   3                          fr_status = P5PU;
 411   3                          BIT_SET_ONE(fr_status, pin);
 412   3                          P5PU = fr_status;
 413   3                          break;
 414   3                      default:
 415   3                          break;
 416   3                  }
 417   2          }
 418   1          return;
 419   1      }
 420          
 421          /// @brief ËÆæÁΩÆ Schmidt(ÊñΩËÄêÂæ∑)Ëß¶Âèë
 422          /// @param port Á´ØÂè£
 423          /// @param pin ÂºïËÑö
 424          /// @param en 0 ÊâìÂºÄ, 1 ÂÖ≥Èó≠
 425          /// @note ‰∏äÁîµÂ§ç‰ΩçÂêéÈªòËÆ§‰ΩøËÉΩ
 426          void GPIO_setSchmidtTrigger(const unsigned char port,
 427                                      const unsigned char pin,
 428                                      const unsigned char en)
 429          {
 430   1          unsigned char fr_status;
 431   1          switch ( en )
 432   1          {
 433   2              case 0:
 434   2                  switch ( port )
 435   2                  {
 436   3                      case 0:
 437   3                          fr_status = P0NCS;
 438   3                          BIT_SET_ZERO(fr_status, pin);
 439   3                          P0NCS = fr_status;
 440   3                          break;
 441   3                      case 1:
 442   3                          fr_status = P1NCS;
 443   3                          BIT_SET_ZERO(fr_status, pin);
 444   3                          P1NCS = fr_status;
 445   3                          break;
 446   3                      case 2:
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 16  

 447   3                          fr_status = P2NCS;
 448   3                          BIT_SET_ZERO(fr_status, pin);
 449   3                          P2NCS = fr_status;
 450   3                          break;
 451   3                      case 3:
 452   3                          fr_status = P3NCS;
 453   3                          BIT_SET_ZERO(fr_status, pin);
 454   3                          P3NCS = fr_status;
 455   3                          break;
 456   3                      case 4:
 457   3                          fr_status = P4NCS;
 458   3                          BIT_SET_ZERO(fr_status, pin);
 459   3                          P4NCS = fr_status;
 460   3                          break;
 461   3                      case 5:
 462   3                          fr_status = P5NCS;
 463   3                          BIT_SET_ZERO(fr_status, pin);
 464   3                          P5NCS = fr_status;
 465   3                          break;
 466   3                      default:
 467   3                          break;
 468   3                  }
 469   2              default:
 470   2                  switch ( port )
 471   2                  {
 472   3                      case 0:
 473   3                          fr_status = P0NCS;
 474   3                          BIT_SET_ONE(fr_status, pin);
 475   3                          P0NCS = fr_status;
 476   3                          break;
 477   3                      case 1:
 478   3                          fr_status = P1NCS;
 479   3                          BIT_SET_ONE(fr_status, pin);
 480   3                          P1NCS = fr_status;
 481   3                          break;
 482   3                      case 2:
 483   3                          fr_status = P2NCS;
 484   3                          BIT_SET_ONE(fr_status, pin);
 485   3                          P2NCS = fr_status;
 486   3                          break;
 487   3                      case 3:
 488   3                          fr_status = P3NCS;
 489   3                          BIT_SET_ONE(fr_status, pin);
 490   3                          P3NCS = fr_status;
 491   3                          break;
 492   3                      case 4:
 493   3                          fr_status = P4NCS;
 494   3                          BIT_SET_ONE(fr_status, pin);
 495   3                          P4NCS = fr_status;
 496   3                          break;
 497   3                      case 5:
 498   3                          fr_status = P5NCS;
 499   3                          BIT_SET_ONE(fr_status, pin);
 500   3                          P5NCS = fr_status;
 501   3                          break;
 502   3                      default:
 503   3                          break;
 504   3                  }
 505   2          }
 506   1          return;
 507   1      }
 508          
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 17  

 509          /// @brief ËÆæÁΩÆÁîµÂπ≥ËΩ¨Êç¢ÈÄüÂ∫¶ÊéßÂà∂
 510          /// @param port Á´ØÂè£
 511          /// @param pin ÂºïËÑö
 512          /// @param en 0 Âø´, 1 ÊÖ¢
 513          void GPIO_setLevelShiftingSpeed(const unsigned char port,
 514                                          const unsigned char pin,
 515                                          const unsigned char en)
 516          {
 517   1          unsigned char fr_status;
 518   1          switch ( en )
 519   1          {
 520   2              case 0:
 521   2                  switch ( port )
 522   2                  {
 523   3                      case 0:
 524   3                          fr_status = P0SR;
 525   3                          BIT_SET_ZERO(fr_status, pin);
 526   3                          P0SR = fr_status;
 527   3                          break;
 528   3                      case 1:
 529   3                          fr_status = P1SR;
 530   3                          BIT_SET_ZERO(fr_status, pin);
 531   3                          P1SR = fr_status;
 532   3                          break;
 533   3                      case 2:
 534   3                          fr_status = P2SR;
 535   3                          BIT_SET_ZERO(fr_status, pin);
 536   3                          P2SR = fr_status;
 537   3                          break;
 538   3                      case 3:
 539   3                          fr_status = P3SR;
 540   3                          BIT_SET_ZERO(fr_status, pin);
 541   3                          P3SR = fr_status;
 542   3                          break;
 543   3                      case 4:
 544   3                          fr_status = P4SR;
 545   3                          BIT_SET_ZERO(fr_status, pin);
 546   3                          P4SR = fr_status;
 547   3                          break;
 548   3                      case 5:
 549   3                          fr_status = P5SR;
 550   3                          BIT_SET_ZERO(fr_status, pin);
 551   3                          P5SR = fr_status;
 552   3                          break;
 553   3                      default:
 554   3                          break;
 555   3                  }
 556   2              default:
 557   2                  switch ( port )
 558   2                  {
 559   3                      case 0:
 560   3                          fr_status = P0SR;
 561   3                          BIT_SET_ONE(fr_status, pin);
 562   3                          P0SR = fr_status;
 563   3                          break;
 564   3                      case 1:
 565   3                          fr_status = P1SR;
 566   3                          BIT_SET_ONE(fr_status, pin);
 567   3                          P1SR = fr_status;
 568   3                          break;
 569   3                      case 2:
 570   3                          fr_status = P2SR;
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 18  

 571   3                          BIT_SET_ONE(fr_status, pin);
 572   3                          P2SR = fr_status;
 573   3                          break;
 574   3                      case 3:
 575   3                          fr_status = P3SR;
 576   3                          BIT_SET_ONE(fr_status, pin);
 577   3                          P3SR = fr_status;
 578   3                          break;
 579   3                      case 4:
 580   3                          fr_status = P4SR;
 581   3                          BIT_SET_ONE(fr_status, pin);
 582   3                          P4SR = fr_status;
 583   3                          break;
 584   3                      case 5:
 585   3                          fr_status = P5SR;
 586   3                          BIT_SET_ONE(fr_status, pin);
 587   3                          P5SR = fr_status;
 588   3                          break;
 589   3                      default:
 590   3                          break;
 591   3                  }
 592   2          }
 593   1          return;
 594   1      }
 595          
 596          /// @brief ËÆæÁΩÆÈ©±Âä®ÁîµÊµÅËÉΩÂäõ
 597          /// @param port Á´ØÂè£
 598          /// @param pin ÂºïËÑö
 599          /// @param en 0 ‰∏ÄËà¨, 1 Â¢ûÂº∫
 600          void GPIO_setDriveCurrent(const unsigned char port,
 601                                    const unsigned char pin,
 602                                    const unsigned char en)
 603          {
 604   1          unsigned char fr_status;
 605   1          switch ( en )
 606   1          {
 607   2              case 0:
 608   2                  switch ( port )
 609   2                  {
 610   3                      case 0:
 611   3                          fr_status = P0DR;
 612   3                          BIT_SET_ZERO(fr_status, pin);
 613   3                          P0DR = fr_status;
 614   3                          break;
 615   3                      case 1:
 616   3                          fr_status = P1DR;
 617   3                          BIT_SET_ZERO(fr_status, pin);
 618   3                          P1DR = fr_status;
 619   3                          break;
 620   3                      case 2:
 621   3                          fr_status = P2DR;
 622   3                          BIT_SET_ZERO(fr_status, pin);
 623   3                          P2DR = fr_status;
 624   3                          break;
 625   3                      case 3:
 626   3                          fr_status = P3DR;
 627   3                          BIT_SET_ZERO(fr_status, pin);
 628   3                          P3DR = fr_status;
 629   3                          break;
 630   3                      case 4:
 631   3                          fr_status = P4DR;
 632   3                          BIT_SET_ZERO(fr_status, pin);
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 19  

 633   3                          P4DR = fr_status;
 634   3                          break;
 635   3                      case 5:
 636   3                          fr_status = P5DR;
 637   3                          BIT_SET_ZERO(fr_status, pin);
 638   3                          P5DR = fr_status;
 639   3                          break;
 640   3                      default:
 641   3                          break;
 642   3                  }
 643   2              default:
 644   2                  switch ( port )
 645   2                  {
 646   3                      case 0:
 647   3                          fr_status = P0DR;
 648   3                          BIT_SET_ONE(fr_status, pin);
 649   3                          P0DR = fr_status;
 650   3                          break;
 651   3                      case 1:
 652   3                          fr_status = P1DR;
 653   3                          BIT_SET_ONE(fr_status, pin);
 654   3                          P1DR = fr_status;
 655   3                          break;
 656   3                      case 2:
 657   3                          fr_status = P2DR;
 658   3                          BIT_SET_ONE(fr_status, pin);
 659   3                          P2DR = fr_status;
 660   3                          break;
 661   3                      case 3:
 662   3                          fr_status = P3DR;
 663   3                          BIT_SET_ONE(fr_status, pin);
 664   3                          P3DR = fr_status;
 665   3                          break;
 666   3                      case 4:
 667   3                          fr_status = P4DR;
 668   3                          BIT_SET_ONE(fr_status, pin);
 669   3                          P4DR = fr_status;
 670   3                          break;
 671   3                      case 5:
 672   3                          fr_status = P5DR;
 673   3                          BIT_SET_ONE(fr_status, pin);
 674   3                          P5DR = fr_status;
 675   3                          break;
 676   3                      default:
 677   3                          break;
 678   3                  }
 679   2          }
 680   1          return;
 681   1      }
 682          
 683          /// @brief Uart1ÂàùÂßãÂåñ
 684          /// @param
 685          /// @note ‰ΩøÁî® timer1‰Ωú‰∏∫Ê≥¢ÁâπÁéáÁîüÊàêÂô®
 686          void UartInit(void) // 115200bps@11.0592MHz
 687          {
 688   1          /*
 689   1              ‰∏≤Âè£ÂõõÁßçÊ®°Âºè:
 690   1              1. mode 0: ÂêåÊ≠•‰ΩçÁßª‰∏≤Ë°å
 691   1              2. mode 1: ÂèØÂèò baudrate 8bits
 692   1              3. mode 2: Âõ∫ÂÆö baudrate 9bits
 693   1              4. mode 3: ÂèØÂèò baudrate 8bits
 694   1          */
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 20  

 695   1      
 696   1      #if CONFIG_DEBUG
                  SCON = 0x50;  // 8 bits and variable baudrate
                  AUXR |= 0x40; // imer clock is 1T mode
                  AUXR &= 0xFE; // UART 1 use Timer1 as baudrate generator
                  TMOD &= 0x0F; // Set timer work mode
              #endif
 702   1      #if !CONFIG_DEBUG
 703   1          unsigned char fr_status;
 704   1          GPIO_setStandardBidirectional(3, 0);
 705   1          GPIO_setStandardBidirectional(3, 1);
 706   1      
 707   1          fr_status = SCON;
 708   1          BIT_SET_ONE(fr_status, 4); // enable uart receive
 709   1          BIT_SET_ONE(fr_status, 6); // set mode1 of UART
 710   1          SCON = fr_status;
 711   1      
 712   1          fr_status = AUXR;
 713   1          BIT_SET_ONE(fr_status, 6);  // timer clock is 1T mode
 714   1          BIT_SET_ZERO(fr_status, 0); // UART 1 use Timer1 as baudrate generator
 715   1          AUXR = fr_status;
 716   1      
 717   1          fr_status = TMOD;
 718   1          BIT_SET_ZERO(fr_status, 5); // 8bit auto reload( timer work mode )
 719   1          TMOD = fr_status;
 720   1      #endif
 721   1          TL1 = BRT;      // Initial timer value
 722   1          TH1 = BRT >> 8; // Initial timer value
 723   1          ET1 = 0;        // Disable Timer%d interrupt
 724   1          ES = 1;         // Enable UART1 interrupt
 725   1          EA = 1;         // Enable global interrupt
 726   1          TR1 = 1;        // Timer1 start run
 727   1      
 728   1          wptr = 0X00;
 729   1          rptr = 0X00;
 730   1          busy = 0;
 731   1      }
 732          
 733          /// @brief UartÂèëÈÄÅ‰∏Ä‰∏™Â≠óËäÇ
 734          /// @param ch
 735          void UartSendByte(unsigned char ch)
 736          {
 737   1          while ( busy )
 738   1              ; // Á≠âÂæÖÂèëÈÄÅÁºìÂÜ≤Âå∫Á©∫Èó≤, Âê¶Âàô‰∏ÄÁõ¥Á≠âÂæÖ
 739   1          busy = 1;
 740   1          SBUF = ch; // Áªô( ÂÜôÁºìÂÜ≤Âå∫ )ÂÜô one byte
 741   1      }
 742          
 743          /// @brief UartÂèëÈÄÅ‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤
 744          /// @param str
 745          void UartSendString(const char* str)
 746          {
 747   1          while ( *str )
 748   1          {
 749   2              UartSendByte(*str++);
 750   2          }
 751   1      }
 752          
 753          
 754          /*
 755          P0  -->P3.3    |P0.0~P0.3   0x0f    0000 1111
 756          P1  -->P0.0    |P1.0~P1.7   0xff    1111 1111
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 21  

 757          P2  -->P0.1    |P2.0~P2.7   0xff    1111 1111
 758          P3  -->P0.2    |P3.3~P3.7   0xf8    1111 1000
 759          P4  -->P0.3
 760          P5  -->P3.4
 761          P6  -->P3.5
 762          P7  -->P3.6
 763          P8  -->P3.7
 764          P9  -->P2.0
 765          P10 -->P2.1
 766          P11 -->P2.2
 767          P12 -->P2.3
 768          P13 -->P1.0
 769          P14 -->P1.1
 770          P15 -->P1.2
 771          P16 -->P1.3
 772          P17 -->P1.4
 773          P18 -->P1.5
 774          P19 -->P1.6
 775          P20 -->P1.7
 776          P21 -->P2.4
 777          P22 -->P2.5
 778          P23 -->P2.6
 779          P24 -->P2.7
 780          */
 781          
 782          /// @brief GPIOÂàùÂßãÂåñ
 783          /// @param
 784          void GPIO_init(void)
 785          {
 786   1          unsigned char output_turbo = IO_TURBO_RESET;
 787   1          unsigned char IO_speed = IO_SPEED_RESET;
 788   1          // P1 P0.0
 789   1          // P0 P3.3
 790   1      
 791   1          P0 = PORT_RESET;    // IOÂ§ç‰Ωç
 792   1          P0M0 = IO_M0_RESET; // ËÆæ‰∏∫È´òÈòªËæìÂÖ•
 793   1          P0M1 = ~IO_M1_RESET;
 794   1      
 795   1          P1 = PORT_RESET;
 796   1          P1M0 = IO_M0_RESET;
 797   1          P1M1 = ~IO_M1_RESET;
 798   1      
 799   1          P2 = PORT_RESET;
 800   1          P2M0 = IO_M0_RESET;
 801   1          P2M1 = ~IO_M1_RESET;
 802   1      
 803   1          P3 = PORT_RESET;
 804   1          P3M0 = IO_M0_RESET;
 805   1          P3M1 = ~IO_M1_RESET;
 806   1      
 807   1          output_turbo = ~IO_TURBO_RESET; // Â¢ûÂº∫È©±Âä®ËÉΩÂäõ
 808   1          P1DR = output_turbo;
 809   1          P2DR = output_turbo;
 810   1          output_turbo = (unsigned char)~USE_P0;
 811   1          P0DR = output_turbo;
 812   1          output_turbo = (unsigned char)~USE_P3;
 813   1          P3DR = output_turbo;
 814   1      
 815   1          IO_speed = ~IO_SPEED_RESET; // ÁîµÂπ≥ËΩ¨Êç¢Âø´
 816   1          P1SR = IO_speed;
 817   1          P2SR = IO_speed;
 818   1          IO_speed = (unsigned char)~USE_P0;
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 22  

 819   1          P0SR = IO_speed;
 820   1          IO_speed = (unsigned char)~USE_P3;
 821   1          P3SR = IO_speed;
 822   1      
 823   1          GPIO_setOpenDrainOutput(3, 3);// P0
 824   1          GPIO_setOpenDrainOutput(0, 0);// P1
 825   1          GPIO_setOpenDrainOutput(0, 1);// P2
 826   1          GPIO_setOpenDrainOutput(0, 2);// P3
 827   1          GPIO_setOpenDrainOutput(0, 3);// P4
 828   1          GPIO_setOpenDrainOutput(3, 4);// P5
 829   1          GPIO_setOpenDrainOutput(3, 5);// P6
 830   1          GPIO_setOpenDrainOutput(3, 6);// P7
 831   1          GPIO_setOpenDrainOutput(3, 7);// P8
 832   1          GPIO_setOpenDrainOutput(2, 0);// P9
 833   1          GPIO_setOpenDrainOutput(2, 1);// P10
 834   1          GPIO_setOpenDrainOutput(2, 2);// P11
 835   1          GPIO_setOpenDrainOutput(2, 3);// P12
 836   1          GPIO_setOpenDrainOutput(1, 0);// P13
 837   1          GPIO_setOpenDrainOutput(1, 1);// P14
 838   1          GPIO_setOpenDrainOutput(1, 2);// P15
 839   1          GPIO_setOpenDrainOutput(1, 3);// P16
 840   1          GPIO_setOpenDrainOutput(1, 4);// P17
 841   1          GPIO_setOpenDrainOutput(1, 5);// P18
 842   1          GPIO_setOpenDrainOutput(1, 6);// P19
 843   1          GPIO_setOpenDrainOutput(1, 7);// P20
 844   1          GPIO_setOpenDrainOutput(2, 4);// P21
 845   1          GPIO_setOpenDrainOutput(2, 5);// P22
 846   1          GPIO_setOpenDrainOutput(2, 6);// P23
 847   1          GPIO_setOpenDrainOutput(2, 7);// P24
 848   1      
 849   1          return;
 850   1      }
 851          
 852          void LED_off(void)
 853          {
 854   1          GPIO_setOpenDrainOutput(3, 3);// P0
 855   1          GPIO_setOpenDrainOutput(0, 0);// P1
 856   1          GPIO_setOpenDrainOutput(0, 1);// P2
 857   1          GPIO_setOpenDrainOutput(0, 2);// P3
 858   1          GPIO_setOpenDrainOutput(0, 3);// P4
 859   1          GPIO_setOpenDrainOutput(3, 4);// P5
 860   1          GPIO_setOpenDrainOutput(3, 5);// P6
 861   1          GPIO_setOpenDrainOutput(3, 6);// P7
 862   1          GPIO_setOpenDrainOutput(3, 7);// P8
 863   1          GPIO_setOpenDrainOutput(2, 0);// P9
 864   1          GPIO_setOpenDrainOutput(2, 1);// P10
 865   1          GPIO_setOpenDrainOutput(2, 2);// P11
 866   1          GPIO_setOpenDrainOutput(2, 3);// P12
 867   1          GPIO_setOpenDrainOutput(1, 0);// P13
 868   1          GPIO_setOpenDrainOutput(1, 1);// P14
 869   1          GPIO_setOpenDrainOutput(1, 2);// P15
 870   1          GPIO_setOpenDrainOutput(1, 3);// P16
 871   1          GPIO_setOpenDrainOutput(1, 4);// P17
 872   1          GPIO_setOpenDrainOutput(1, 5);// P18
 873   1          GPIO_setOpenDrainOutput(1, 6);// P19
 874   1          GPIO_setOpenDrainOutput(1, 7);// P20
 875   1          GPIO_setOpenDrainOutput(2, 4);// P21
 876   1          GPIO_setOpenDrainOutput(2, 5);// P22
 877   1          GPIO_setOpenDrainOutput(2, 6);// P23
 878   1          GPIO_setOpenDrainOutput(2, 7);// P24
 879   1      
 880   1          P0 = USE_P0;
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 23  

 881   1          P1 = USE_P1;
 882   1          P2 = USE_P2;
 883   1          P3 = USE_P3;
 884   1      }
 885          
 886          #if LED_DEBUG
 887          /// @brief LED ÂÖ®ÂºÄ
 888          /// @param LED_line
 889          /// @note ÂΩì‰∏ªÂæ™ÁéØ‰∏≠ÊèíÂÖ•Â≠óÁ¨¶‰∏≤ËæìÂá∫Êó∂, ‰ºöÊúâÊòéÊòæÈó™ÁÉÅ, ‰ΩÜ‰∫ÆÂ∫¶ËæÉÈ´ò
 890          void LED_allON(unsigned char LED_line)
 891          {
 892   1          switch ( LED_line )
 893   1          {
 894   2              case 0:
 895   2                  GPIO_setOpenDrainOutput(3, 3);//  P0
 896   2                  GPIO_setPushPullupOutput(0, 0);// P1
 897   2                  P2 = ~USE_P2;
 898   2                  P1 = ~USE_P1;
 899   2                  P0 &= ~USE_P0;
 900   2                  P3 &= ~USE_P3;
 901   2                  P27 = 0;
 902   2                  P00 = 1;
 903   2                  break;
 904   2              case 1:
 905   2                  GPIO_setOpenDrainOutput(0, 0);//  P1
 906   2                  GPIO_setPushPullupOutput(0, 1);// P2
 907   2                  P2 = ~USE_P2;
 908   2                  P1 = ~USE_P1;
 909   2                  P0 &= ~USE_P0;
 910   2                  P3 &= ~USE_P3;
 911   2                  P00 = 0;
 912   2                  P01 = 1;
 913   2                  break;
 914   2              case 2:
 915   2                  GPIO_setOpenDrainOutput(0, 1);//  P2
 916   2                  GPIO_setPushPullupOutput(0, 2);// P3
 917   2                  P2 = ~USE_P2;
 918   2                  P1 = ~USE_P1;
 919   2                  P0 &= ~USE_P0;
 920   2                  P3 &= ~USE_P3;
 921   2                  P01 = 0;
 922   2                  P02 = 1;
 923   2                  break;
 924   2              case 3:
 925   2                  GPIO_setOpenDrainOutput(0, 2);//  P3
 926   2                  GPIO_setPushPullupOutput(0, 3);// P4
 927   2                  P2 = ~USE_P2;
 928   2                  P1 = ~USE_P1;
 929   2                  P0 &= ~USE_P0;
 930   2                  P3 &= ~USE_P3;
 931   2                  P02 = 0;
 932   2                  P03 = 1;
 933   2                  break;
 934   2              case 4:
 935   2                  GPIO_setOpenDrainOutput(0, 3);//  P4
 936   2                  GPIO_setPushPullupOutput(3, 4);// P5
 937   2                  P2 = ~USE_P2;
 938   2                  P1 = ~USE_P1;
 939   2                  P0 &= ~USE_P0;
 940   2                  P3 &= ~USE_P3;
 941   2                  P03 = 0;
 942   2                  P34 = 1;
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 24  

 943   2                  break;
 944   2              case 5:
 945   2                  GPIO_setOpenDrainOutput(3, 4);//  P5
 946   2                  GPIO_setPushPullupOutput(3, 5);// P6
 947   2                  P2 = ~USE_P2;
 948   2                  P1 = ~USE_P1;
 949   2                  P0 &= ~USE_P0;
 950   2                  P3 &= ~USE_P3;
 951   2                  P34 = 0;
 952   2                  P35 = 1;
 953   2                  break;
 954   2              case 6:
 955   2                  GPIO_setOpenDrainOutput(3, 5);//  P6
 956   2                  GPIO_setPushPullupOutput(3, 6);// P7
 957   2                  P2 = ~USE_P2;
 958   2                  P1 = ~USE_P1;
 959   2                  P0 &= ~USE_P0;
 960   2                  P3 &= ~USE_P3;
 961   2                  P35 = 0;
 962   2                  P36 = 1;
 963   2                  break;
 964   2              case 7:
 965   2                  GPIO_setOpenDrainOutput(3, 6);//  P7
 966   2                  GPIO_setPushPullupOutput(3, 7);// P8
 967   2                  P2 = ~USE_P2;
 968   2                  P1 = ~USE_P1;
 969   2                  P0 &= ~USE_P0;
 970   2                  P3 &= ~USE_P3;
 971   2                  P36 = 0;
 972   2                  P37 = 1;
 973   2                  break;
 974   2              case 8:
 975   2                  GPIO_setOpenDrainOutput(3, 7);//  P8
 976   2                  GPIO_setPushPullupOutput(2, 0);// P9
 977   2                  P2 = ~USE_P2;
 978   2                  P1 = ~USE_P1;
 979   2                  P0 &= ~USE_P0;
 980   2                  P3 &= ~USE_P3;
 981   2                  P37 = 0;
 982   2                  P20 = 1;
 983   2                  break;
 984   2              case 9:
 985   2                  GPIO_setOpenDrainOutput(2, 0);//  P9
 986   2                  GPIO_setPushPullupOutput(2, 1);//P10
 987   2                  P2 = ~USE_P2;
 988   2                  P1 = ~USE_P1;
 989   2                  P0 &= ~USE_P0;
 990   2                  P3 &= ~USE_P3;
 991   2                  P20 = 0;
 992   2                  P21 = 1;
 993   2                  break;
 994   2              case 10:
 995   2                  GPIO_setOpenDrainOutput(2, 1);// P10
 996   2                  GPIO_setPushPullupOutput(2, 2);//P11
 997   2                  P2 = ~USE_P2;
 998   2                  P1 = ~USE_P1;
 999   2                  P0 &= ~USE_P0;
1000   2                  P3 &= ~USE_P3;
1001   2                  P21 = 0;
1002   2                  P22 = 1;
1003   2                  break;
1004   2              case 11:
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 25  

1005   2                  GPIO_setOpenDrainOutput(2, 2);// P11
1006   2                  GPIO_setPushPullupOutput(2, 3);//P12
1007   2                  P2 = ~USE_P2;
1008   2                  P1 = ~USE_P1;
1009   2                  P0 &= ~USE_P0;
1010   2                  P3 &= ~USE_P3;
1011   2                  P22 = 0;
1012   2                  P23 = 1;
1013   2                  break;
1014   2              case 12:
1015   2                  GPIO_setOpenDrainOutput(2, 3);// P12
1016   2                  GPIO_setPushPullupOutput(1, 0);//P13
1017   2                  P2 = ~USE_P2;
1018   2                  P1 = ~USE_P1;
1019   2                  P0 &= ~USE_P0;
1020   2                  P3 &= ~USE_P3;
1021   2                  P23 = 0;
1022   2                  P10 = 1;
1023   2                  break;
1024   2              case 13:
1025   2                  GPIO_setOpenDrainOutput(1, 0);// P13
1026   2                  GPIO_setPushPullupOutput(1, 1);//P14
1027   2                  P2 = ~USE_P2;
1028   2                  P1 = ~USE_P1;
1029   2                  P0 &= ~USE_P0;
1030   2                  P3 &= ~USE_P3;
1031   2                  P10 = 0;
1032   2                  P11 = 1;
1033   2                  break;
1034   2              case 14:
1035   2                  GPIO_setOpenDrainOutput(1, 1);// P14
1036   2                  GPIO_setPushPullupOutput(1, 2);//P15
1037   2                  P2 = ~USE_P2;
1038   2                  P1 = ~USE_P1;
1039   2                  P0 &= ~USE_P0;
1040   2                  P3 &= ~USE_P3;
1041   2                  P11 = 0;
1042   2                  P12 = 1;
1043   2                  break;
1044   2              case 15:
1045   2                  GPIO_setOpenDrainOutput(1, 2);// P15
1046   2                  GPIO_setPushPullupOutput(1, 3);//P16
1047   2                  P2 = ~USE_P2;
1048   2                  P1 = ~USE_P1;
1049   2                  P0 &= ~USE_P0;
1050   2                  P3 &= ~USE_P3;
1051   2                  P12 = 0;
1052   2                  P13 = 1;
1053   2                  break;
1054   2              case 16:
1055   2                  GPIO_setOpenDrainOutput(1, 3);// P16
1056   2                  GPIO_setPushPullupOutput(1, 4);//P17
1057   2                  P2 = ~USE_P2;
1058   2                  P1 = ~USE_P1;
1059   2                  P0 &= ~USE_P0;
1060   2                  P3 &= ~USE_P3;
1061   2                  P13 = 0;
1062   2                  P14 = 1;
1063   2                  break;
1064   2              case 17:
1065   2                  GPIO_setOpenDrainOutput(1, 4);// P17
1066   2                  GPIO_setPushPullupOutput(1, 5);//P18
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 26  

1067   2                  P2 = ~USE_P2;
1068   2                  P1 = ~USE_P1;
1069   2                  P0 &= ~USE_P0;
1070   2                  P3 &= ~USE_P3;
1071   2                  P14 = 0;
1072   2                  P15 = 1;
1073   2                  break;
1074   2              case 18:
1075   2                  GPIO_setOpenDrainOutput(1, 5);// P18
1076   2                  GPIO_setPushPullupOutput(1, 6);//P19
1077   2                  P2 = ~USE_P2;
1078   2                  P1 = ~USE_P1;
1079   2                  P0 &= ~USE_P0;
1080   2                  P3 &= ~USE_P3;
1081   2                  P15 = 0;
1082   2                  P16 = 1;
1083   2                  break;
1084   2              case 19:
1085   2                  GPIO_setOpenDrainOutput(1, 6);// P19
1086   2                  GPIO_setPushPullupOutput(1, 7);//P20
1087   2                  P2 = ~USE_P2;
1088   2                  P1 = ~USE_P1;
1089   2                  P0 &= ~USE_P0;
1090   2                  P3 &= ~USE_P3;
1091   2                  P16 = 0;
1092   2                  P17 = 1;
1093   2                  break;
1094   2              case 20:
1095   2                  GPIO_setOpenDrainOutput(1, 7);// P20
1096   2                  GPIO_setPushPullupOutput(2, 4);//P21
1097   2                  P2 = ~USE_P2;
1098   2                  P1 = ~USE_P1;
1099   2                  P0 &= ~USE_P0;
1100   2                  P3 &= ~USE_P3;
1101   2                  P17 = 0;
1102   2                  P24 = 1;
1103   2                  break;
1104   2              case 21:
1105   2                  GPIO_setOpenDrainOutput(2, 4);// P21
1106   2                  GPIO_setPushPullupOutput(2, 5);//P22
1107   2                  P2 = ~USE_P2;
1108   2                  P1 = ~USE_P1;
1109   2                  P0 &= ~USE_P0;
1110   2                  P3 &= ~USE_P3;
1111   2                  P24 = 0;
1112   2                  P25 = 1;
1113   2                  break;
1114   2              case 22:
1115   2                  GPIO_setOpenDrainOutput(2, 5);// P22
1116   2                  GPIO_setPushPullupOutput(2, 6);//P23
1117   2                  P2 = ~USE_P2;
1118   2                  P1 = ~USE_P1;
1119   2                  P0 &= ~USE_P0;
1120   2                  P3 &= ~USE_P3;
1121   2                  P25 = 0;
1122   2                  P26 = 1;
1123   2                  break;
1124   2              case 23:
1125   2                  GPIO_setOpenDrainOutput(2, 6);// P23
1126   2                  GPIO_setPushPullupOutput(2, 7);//P24
1127   2                  P2 = ~USE_P2;
1128   2                  P1 = ~USE_P1;
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 27  

1129   2                  P0 &= ~USE_P0;
1130   2                  P3 &= ~USE_P3;
1131   2                  P26 = 0;
1132   2                  P27 = 1;
1133   2                  break;
1134   2              case 24:
1135   2                  GPIO_setOpenDrainOutput(2, 7);// P24
1136   2                  GPIO_setPushPullupOutput(3, 3);// P0
1137   2                  P2 = ~USE_P2;
1138   2                  P1 = ~USE_P1;
1139   2                  P0 &= ~USE_P0;
1140   2                  P3 &= ~USE_P3;
1141   2                  P27 = 0;
1142   2                  P33 = 1;
1143   2                  break;
1144   2      
1145   2              default:
1146   2                  return;
1147   2          }
1148   1      
1149   1      }
1150          
1151          /// @brief LED ÂÖ®ÂºÄÊµãËØï
1152          /// @param  
1153          /// @note ÂΩì‰∏ªÂæ™ÁéØ‰∏≠ÊèíÂÖ•Â≠óÁ¨¶‰∏≤ËæìÂá∫Êó∂, Ê≤°ÊúâÊúâÊòéÊòæÈó™ÁÉÅ, ‰ΩÜ‰∫ÆÂ∫¶ËæÉ‰Ωé
1154          void LED_allON_test(void)
1155          {
1156   1          GPIO_setOpenDrainOutput(3, 3);//  P0
1157   1          GPIO_setPushPullupOutput(0, 0);// P1
1158   1          P2 = ~USE_P2;
1159   1          P1 = ~USE_P1;
1160   1          P0 &= ~USE_P0;
1161   1          P3 &= ~USE_P3;
1162   1          P27 = 0;
1163   1          P00 = 1;
1164   1      
1165   1          GPIO_setOpenDrainOutput(0, 0);//  P1
1166   1          GPIO_setPushPullupOutput(0, 1);// P2
1167   1          P2 = ~USE_P2;
1168   1          P1 = ~USE_P1;
1169   1          P0 &= ~USE_P0;
1170   1          P3 &= ~USE_P3;
1171   1          P00 = 0;
1172   1          P01 = 1;
1173   1      
1174   1          GPIO_setOpenDrainOutput(0, 1);//  P2
1175   1          GPIO_setPushPullupOutput(0, 2);// P3
1176   1          P2 = ~USE_P2;
1177   1          P1 = ~USE_P1;
1178   1          P0 &= ~USE_P0;
1179   1          P3 &= ~USE_P3;
1180   1          P01 = 0;
1181   1          P02 = 1;
1182   1      
1183   1          GPIO_setOpenDrainOutput(0, 2);//  P3
1184   1          GPIO_setPushPullupOutput(0, 3);// P4
1185   1          P2 = ~USE_P2;
1186   1          P1 = ~USE_P1;
1187   1          P0 &= ~USE_P0;
1188   1          P3 &= ~USE_P3;
1189   1          P02 = 0;
1190   1          P03 = 1;
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 28  

1191   1      
1192   1          GPIO_setOpenDrainOutput(0, 3);//  P4
1193   1          GPIO_setPushPullupOutput(3, 4);// P5
1194   1          P2 = ~USE_P2;
1195   1          P1 = ~USE_P1;
1196   1          P0 &= ~USE_P0;
1197   1          P3 &= ~USE_P3;
1198   1          P03 = 0;
1199   1          P34 = 1;
1200   1      
1201   1          GPIO_setOpenDrainOutput(3, 4);//  P5
1202   1          GPIO_setPushPullupOutput(3, 5);// P6
1203   1          P2 = ~USE_P2;
1204   1          P1 = ~USE_P1;
1205   1          P0 &= ~USE_P0;
1206   1          P3 &= ~USE_P3;
1207   1          P34 = 0;
1208   1          P35 = 1;
1209   1      
1210   1          GPIO_setOpenDrainOutput(3, 5);//  P6
1211   1          GPIO_setPushPullupOutput(3, 6);// P7
1212   1          P2 = ~USE_P2;
1213   1          P1 = ~USE_P1;
1214   1          P0 &= ~USE_P0;
1215   1          P3 &= ~USE_P3;
1216   1          P35 = 0;
1217   1          P36 = 1;
1218   1      
1219   1          GPIO_setOpenDrainOutput(3, 6);//  P7
1220   1          GPIO_setPushPullupOutput(3, 7);// P8
1221   1          P2 = ~USE_P2;
1222   1          P1 = ~USE_P1;
1223   1          P0 &= ~USE_P0;
1224   1          P3 &= ~USE_P3;
1225   1          P36 = 0;
1226   1          P37 = 1;
1227   1      
1228   1          GPIO_setOpenDrainOutput(3, 7);//  P8
1229   1          GPIO_setPushPullupOutput(2, 0);// P9
1230   1          P2 = ~USE_P2;
1231   1          P1 = ~USE_P1;
1232   1          P0 &= ~USE_P0;
1233   1          P3 &= ~USE_P3;
1234   1          P37 = 0;
1235   1          P20 = 1;
1236   1      
1237   1          GPIO_setOpenDrainOutput(2, 0);//  P9
1238   1          GPIO_setPushPullupOutput(2, 1);//P10
1239   1          P2 = ~USE_P2;
1240   1          P1 = ~USE_P1;
1241   1          P0 &= ~USE_P0;
1242   1          P3 &= ~USE_P3;
1243   1          P20 = 0;
1244   1          P21 = 1;
1245   1      
1246   1          GPIO_setOpenDrainOutput(2, 1);// P10
1247   1          GPIO_setPushPullupOutput(2, 2);//P11
1248   1          P2 = ~USE_P2;
1249   1          P1 = ~USE_P1;
1250   1          P0 &= ~USE_P0;
1251   1          P3 &= ~USE_P3;
1252   1          P21 = 0;
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 29  

1253   1          P22 = 1;
1254   1      
1255   1          GPIO_setOpenDrainOutput(2, 2);// P11
1256   1          GPIO_setPushPullupOutput(2, 3);//P12
1257   1          P2 = ~USE_P2;
1258   1          P1 = ~USE_P1;
1259   1          P0 &= ~USE_P0;
1260   1          P3 &= ~USE_P3;
1261   1          P22 = 0;
1262   1          P23 = 1;
1263   1      
1264   1          GPIO_setOpenDrainOutput(2, 3);// P12
1265   1          GPIO_setPushPullupOutput(1, 0);//P13
1266   1          P2 = ~USE_P2;
1267   1          P1 = ~USE_P1;
1268   1          P0 &= ~USE_P0;
1269   1          P3 &= ~USE_P3;
1270   1          P23 = 0;
1271   1          P10 = 1;
1272   1      
1273   1          GPIO_setOpenDrainOutput(1, 0);// P13
1274   1          GPIO_setPushPullupOutput(1, 1);//P14
1275   1          P2 = ~USE_P2;
1276   1          P1 = ~USE_P1;
1277   1          P0 &= ~USE_P0;
1278   1          P3 &= ~USE_P3;
1279   1          P10 = 0;
1280   1          P11 = 1;
1281   1      
1282   1          GPIO_setOpenDrainOutput(1, 1);// P14
1283   1          GPIO_setPushPullupOutput(1, 2);//P15
1284   1          P2 = ~USE_P2;
1285   1          P1 = ~USE_P1;
1286   1          P0 &= ~USE_P0;
1287   1          P3 &= ~USE_P3;
1288   1          P11 = 0;
1289   1          P12 = 1;
1290   1      
1291   1          GPIO_setOpenDrainOutput(1, 2);// P15
1292   1          GPIO_setPushPullupOutput(1, 3);//P16
1293   1          P2 = ~USE_P2;
1294   1          P1 = ~USE_P1;
1295   1          P0 &= ~USE_P0;
1296   1          P3 &= ~USE_P3;
1297   1          P12 = 0;
1298   1          P13 = 1;
1299   1      
1300   1          GPIO_setOpenDrainOutput(1, 3);// P16
1301   1          GPIO_setPushPullupOutput(1, 4);//P17
1302   1          P2 = ~USE_P2;
1303   1          P1 = ~USE_P1;
1304   1          P0 &= ~USE_P0;
1305   1          P3 &= ~USE_P3;
1306   1          P13 = 0;
1307   1          P14 = 1;
1308   1      
1309   1          GPIO_setOpenDrainOutput(1, 4);// P17
1310   1          GPIO_setPushPullupOutput(1, 5);//P18
1311   1          P2 = ~USE_P2;
1312   1          P1 = ~USE_P1;
1313   1          P0 &= ~USE_P0;
1314   1          P3 &= ~USE_P3;
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 30  

1315   1          P14 = 0;
1316   1          P15 = 1;
1317   1      
1318   1          GPIO_setOpenDrainOutput(1, 5);// P18
1319   1          GPIO_setPushPullupOutput(1, 6);//P19
1320   1          P2 = ~USE_P2;
1321   1          P1 = ~USE_P1;
1322   1          P0 &= ~USE_P0;
1323   1          P3 &= ~USE_P3;
1324   1          P15 = 0;
1325   1          P16 = 1;
1326   1      
1327   1          GPIO_setOpenDrainOutput(1, 6);// P19
1328   1          GPIO_setPushPullupOutput(1, 7);//P20
1329   1          P2 = ~USE_P2;
1330   1          P1 = ~USE_P1;
1331   1          P0 &= ~USE_P0;
1332   1          P3 &= ~USE_P3;
1333   1          P16 = 0;
1334   1          P17 = 1;
1335   1      
1336   1          GPIO_setOpenDrainOutput(1, 7);// P20
1337   1          GPIO_setPushPullupOutput(2, 4);//P21
1338   1          P2 = ~USE_P2;
1339   1          P1 = ~USE_P1;
1340   1          P0 &= ~USE_P0;
1341   1          P3 &= ~USE_P3;
1342   1          P17 = 0;
1343   1          P24 = 1;
1344   1      
1345   1          GPIO_setOpenDrainOutput(2, 4);// P21
1346   1          GPIO_setPushPullupOutput(2, 5);//P22
1347   1          P2 = ~USE_P2;
1348   1          P1 = ~USE_P1;
1349   1          P0 &= ~USE_P0;
1350   1          P3 &= ~USE_P3;
1351   1          P24 = 0;
1352   1          P25 = 1;
1353   1      
1354   1          GPIO_setOpenDrainOutput(2, 5);// P22
1355   1          GPIO_setPushPullupOutput(2, 6);//P23
1356   1          P2 = ~USE_P2;
1357   1          P1 = ~USE_P1;
1358   1          P0 &= ~USE_P0;
1359   1          P3 &= ~USE_P3;
1360   1          P25 = 0;
1361   1          P26 = 1;
1362   1      
1363   1          GPIO_setOpenDrainOutput(2, 6);// P23
1364   1          GPIO_setPushPullupOutput(2, 7);//P24
1365   1          P2 = ~USE_P2;
1366   1          P1 = ~USE_P1;
1367   1          P0 &= ~USE_P0;
1368   1          P3 &= ~USE_P3;
1369   1          P26 = 0;
1370   1          P27 = 1;
1371   1      
1372   1          GPIO_setOpenDrainOutput(2, 7);// P24
1373   1          GPIO_setPushPullupOutput(3, 3);// P0
1374   1          P2 = ~USE_P2;
1375   1          P1 = ~USE_P1;
1376   1          P0 &= ~USE_P0;
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 31  

1377   1          P3 &= ~USE_P3;
1378   1          P27 = 0;
1379   1          P33 = 1;
1380   1      
1381   1          return;
1382   1      
1383   1      }
1384          
1385          void LED_leftON_test(void)
1386          {
1387   1          GPIO_setOpenDrainOutput(3, 3);//  P0
1388   1          GPIO_setPushPullupOutput(0, 0);// P1
1389   1          P2 = ~USE_P2;
1390   1          P1 = ~USE_P1;
1391   1          P0 &= ~USE_P0;
1392   1          P3 &= ~USE_P3;
1393   1          P27 = 0;
1394   1          P00 = 1;
1395   1      
1396   1          GPIO_setOpenDrainOutput(0, 0);//  P1
1397   1          GPIO_setPushPullupOutput(0, 1);// P2
1398   1          P2 = ~USE_P2;
1399   1          P1 = ~USE_P1;
1400   1          P0 &= ~USE_P0;
1401   1          P3 &= ~USE_P3;
1402   1          P00 = 0;
1403   1          P01 = 1;
1404   1      
1405   1          GPIO_setOpenDrainOutput(0, 1);//  P2
1406   1          GPIO_setPushPullupOutput(0, 2);// P3
1407   1          P2 = ~USE_P2;
1408   1          P1 = ~USE_P1;
1409   1          P0 &= ~USE_P0;
1410   1          P3 &= ~USE_P3;
1411   1          P01 = 0;
1412   1          P02 = 1;
1413   1      
1414   1          GPIO_setOpenDrainOutput(0, 2);//  P3
1415   1          GPIO_setPushPullupOutput(0, 3);// P4
1416   1          P2 = ~USE_P2;
1417   1          P1 = ~USE_P1;
1418   1          P0 &= ~USE_P0;
1419   1          P3 &= ~USE_P3;
1420   1          P02 = 0;
1421   1          P03 = 1;
1422   1      
1423   1          GPIO_setOpenDrainOutput(0, 3);//  P4
1424   1          GPIO_setPushPullupOutput(3, 4);// P5
1425   1          P2 = ~USE_P2;
1426   1          P1 = ~USE_P1;
1427   1          P0 &= ~USE_P0;
1428   1          P3 &= ~USE_P3;
1429   1          P03 = 0;
1430   1          P34 = 1;
1431   1      
1432   1          GPIO_setOpenDrainOutput(3, 4);//  P5
1433   1          GPIO_setPushPullupOutput(3, 5);// P6
1434   1          P2 = ~USE_P2;
1435   1          P1 = ~USE_P1;
1436   1          P0 &= ~USE_P0;
1437   1          P3 &= ~USE_P3;
1438   1          P34 = 0;
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 32  

1439   1          P35 = 1;
1440   1      
1441   1          GPIO_setOpenDrainOutput(3, 5);//  P6
1442   1          GPIO_setPushPullupOutput(3, 6);// P7
1443   1          P2 = ~USE_P2;
1444   1          P1 = ~USE_P1;
1445   1          P0 &= ~USE_P0;
1446   1          P3 &= ~USE_P3;
1447   1          P35 = 0;
1448   1          P36 = 1;
1449   1      
1450   1          GPIO_setOpenDrainOutput(3, 6);//  P7
1451   1          GPIO_setPushPullupOutput(3, 7);// P8
1452   1          P2 = ~USE_P2;
1453   1          P1 = ~USE_P1;
1454   1          P0 &= ~USE_P0;
1455   1          P3 &= ~USE_P3;
1456   1          P36 = 0;
1457   1          P37 = 1;
1458   1      
1459   1          GPIO_setOpenDrainOutput(3, 7);//  P8
1460   1          GPIO_setPushPullupOutput(2, 0);// P9
1461   1          P2 = ~USE_P2;
1462   1          P1 = ~USE_P1;
1463   1          P0 &= ~USE_P0;
1464   1          P3 &= ~USE_P3;
1465   1          P37 = 0;
1466   1          P20 = 1;
1467   1      
1468   1          GPIO_setOpenDrainOutput(2, 0);//  P9
1469   1          GPIO_setPushPullupOutput(2, 1);//P10
1470   1          P2 = ~USE_P2;
1471   1          P1 = ~USE_P1;
1472   1          P0 &= ~USE_P0;
1473   1          P3 &= ~USE_P3;
1474   1          P20 = 0;
1475   1          P21 = 1;
1476   1      
1477   1          GPIO_setOpenDrainOutput(2, 1);// P10
1478   1          GPIO_setPushPullupOutput(2, 2);//P11
1479   1          P2 = ~USE_P2;
1480   1          P1 = ~USE_P1;
1481   1          P0 &= ~USE_P0;
1482   1          P3 &= ~USE_P3;
1483   1          P21 = 0;
1484   1          P22 = 1;
1485   1      
1486   1          GPIO_setOpenDrainOutput(2, 2);// P11
1487   1          GPIO_setPushPullupOutput(2, 3);//P12
1488   1          P2 = ~USE_P2;
1489   1          P1 = ~USE_P1;
1490   1          P0 &= ~USE_P0;
1491   1          P3 &= ~USE_P3;
1492   1          P22 = 0;
1493   1          P23 = 1;
1494   1      
1495   1          return;
1496   1      }
1497          
1498          void LED_rightON_test(void)
1499          {
1500   1          GPIO_setOpenDrainOutput(2, 3);// P12
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 33  

1501   1          GPIO_setPushPullupOutput(1, 0);//P13
1502   1          P2 = ~USE_P2;
1503   1          P1 = ~USE_P1;
1504   1          P0 &= ~USE_P0;
1505   1          P3 &= ~USE_P3;
1506   1          P23 = 0;
1507   1          P10 = 1;
1508   1      
1509   1          GPIO_setOpenDrainOutput(1, 0);// P13
1510   1          GPIO_setPushPullupOutput(1, 1);//P14
1511   1          P2 = ~USE_P2;
1512   1          P1 = ~USE_P1;
1513   1          P0 &= ~USE_P0;
1514   1          P3 &= ~USE_P3;
1515   1          P10 = 0;
1516   1          P11 = 1;
1517   1      
1518   1          GPIO_setOpenDrainOutput(1, 1);// P14
1519   1          GPIO_setPushPullupOutput(1, 2);//P15
1520   1          P2 = ~USE_P2;
1521   1          P1 = ~USE_P1;
1522   1          P0 &= ~USE_P0;
1523   1          P3 &= ~USE_P3;
1524   1          P11 = 0;
1525   1          P12 = 1;
1526   1      
1527   1          GPIO_setOpenDrainOutput(1, 2);// P15
1528   1          GPIO_setPushPullupOutput(1, 3);//P16
1529   1          P2 = ~USE_P2;
1530   1          P1 = ~USE_P1;
1531   1          P0 &= ~USE_P0;
1532   1          P3 &= ~USE_P3;
1533   1          P12 = 0;
1534   1          P13 = 1;
1535   1      
1536   1          GPIO_setOpenDrainOutput(1, 3);// P16
1537   1          GPIO_setPushPullupOutput(1, 4);//P17
1538   1          P2 = ~USE_P2;
1539   1          P1 = ~USE_P1;
1540   1          P0 &= ~USE_P0;
1541   1          P3 &= ~USE_P3;
1542   1          P13 = 0;
1543   1          P14 = 1;
1544   1      
1545   1          GPIO_setOpenDrainOutput(1, 4);// P17
1546   1          GPIO_setPushPullupOutput(1, 5);//P18
1547   1          P2 = ~USE_P2;
1548   1          P1 = ~USE_P1;
1549   1          P0 &= ~USE_P0;
1550   1          P3 &= ~USE_P3;
1551   1          P14 = 0;
1552   1          P15 = 1;
1553   1      
1554   1          GPIO_setOpenDrainOutput(1, 5);// P18
1555   1          GPIO_setPushPullupOutput(1, 6);//P19
1556   1          P2 = ~USE_P2;
1557   1          P1 = ~USE_P1;
1558   1          P0 &= ~USE_P0;
1559   1          P3 &= ~USE_P3;
1560   1          P15 = 0;
1561   1          P16 = 1;
1562   1      
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 34  

1563   1          GPIO_setOpenDrainOutput(1, 6);// P19
1564   1          GPIO_setPushPullupOutput(1, 7);//P20
1565   1          P2 = ~USE_P2;
1566   1          P1 = ~USE_P1;
1567   1          P0 &= ~USE_P0;
1568   1          P3 &= ~USE_P3;
1569   1          P16 = 0;
1570   1          P17 = 1;
1571   1      
1572   1          GPIO_setOpenDrainOutput(1, 7);// P20
1573   1          GPIO_setPushPullupOutput(2, 4);//P21
1574   1          P2 = ~USE_P2;
1575   1          P1 = ~USE_P1;
1576   1          P0 &= ~USE_P0;
1577   1          P3 &= ~USE_P3;
1578   1          P17 = 0;
1579   1          P24 = 1;
1580   1      
1581   1          GPIO_setOpenDrainOutput(2, 4);// P21
1582   1          GPIO_setPushPullupOutput(2, 5);//P22
1583   1          P2 = ~USE_P2;
1584   1          P1 = ~USE_P1;
1585   1          P0 &= ~USE_P0;
1586   1          P3 &= ~USE_P3;
1587   1          P24 = 0;
1588   1          P25 = 1;
1589   1      
1590   1          GPIO_setOpenDrainOutput(2, 5);// P22
1591   1          GPIO_setPushPullupOutput(2, 6);//P23
1592   1          P2 = ~USE_P2;
1593   1          P1 = ~USE_P1;
1594   1          P0 &= ~USE_P0;
1595   1          P3 &= ~USE_P3;
1596   1          P25 = 0;
1597   1          P26 = 1;
1598   1      
1599   1          GPIO_setOpenDrainOutput(2, 6);// P23
1600   1          GPIO_setPushPullupOutput(2, 7);//P24
1601   1          P2 = ~USE_P2;
1602   1          P1 = ~USE_P1;
1603   1          P0 &= ~USE_P0;
1604   1          P3 &= ~USE_P3;
1605   1          P26 = 0;
1606   1          P27 = 1;
1607   1      
1608   1          GPIO_setOpenDrainOutput(2, 7);// P24
1609   1          GPIO_setPushPullupOutput(3, 3);// P0
1610   1          P2 = ~USE_P2;
1611   1          P1 = ~USE_P1;
1612   1          P0 &= ~USE_P0;
1613   1          P3 &= ~USE_P3;
1614   1          P27 = 0;
1615   1          P33 = 1;
1616   1      
1617   1          return;
1618   1      }
1619          
1620          void LED_twoBytes_test(void)
1621          {
1622   1          P0 &= ~USE_P0;                 // enable P0.0~P0.3
1623   1          P1 = USE_P1;                   // disable P1.0~P1.7
1624   1          P2 &= ~(USE_P2 >> 4);          // enable P2.0~P2.3, disable P2.4~P2.7
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 35  

1625   1      
1626   1          GPIO_setOpenDrainOutput(3, 3);//  P0
1627   1          GPIO_setPushPullupOutput(0, 0);// P1
1628   1          P0 &= ~USE_P0;                 // enable P0.0~P0.3
1629   1          P2 &= ~(USE_P2 >> 4);           // enable P2.0~P2.3, disable P2.4~P2.7
1630   1          P3 &= ~USE_P3;                 // enable P3.3~P3.7
1631   1          P00 = 1;
1632   1      
1633   1          GPIO_setOpenDrainOutput(0, 0);//  P1
1634   1          GPIO_setPushPullupOutput(0, 1);// P2
1635   1          P0 &= ~USE_P0;
1636   1          P2 &= ~(USE_P2 >> 4);           // enable P2.0~P2.3, disable P2.4~P2.7
1637   1          P3 &= ~USE_P3;
1638   1          P01 = 1;
1639   1      
1640   1          GPIO_setOpenDrainOutput(0, 1);//  P2
1641   1          GPIO_setPushPullupOutput(0, 2);// P3
1642   1          P0 &= ~USE_P0;
1643   1          P2 &= ~(USE_P2 >> 4);           // enable P2.0~P2.3, disable P2.4~P2.7
1644   1          P3 &= ~USE_P3;
1645   1          P02 = 1;
1646   1      
1647   1          GPIO_setOpenDrainOutput(0, 2);//  P3
1648   1          GPIO_setPushPullupOutput(0, 3);// P4
1649   1          P0 &= ~USE_P0;
1650   1          P2 &= ~(USE_P2 >> 4);           // enable P2.0~P2.3, disable P2.4~P2.7
1651   1          P3 &= ~USE_P3;
1652   1          P03 = 1;
1653   1      
1654   1          GPIO_setOpenDrainOutput(0, 3);//  P4
1655   1          GPIO_setPushPullupOutput(3, 4);// P5
1656   1          P0 &= ~USE_P0;
1657   1          P2 &= ~(USE_P2 >> 4);           // enable P2.0~P2.3, disable P2.4~P2.7
1658   1          P3 &= ~USE_P3;
1659   1          P34 = 1;
1660   1      
1661   1          GPIO_setOpenDrainOutput(3, 4);//  P5
1662   1          GPIO_setPushPullupOutput(3, 5);// P6
1663   1          P0 &= ~USE_P0;
1664   1          P2 &= ~(USE_P2 >> 4);           // enable P2.0~P2.3, disable P2.4~P2.7
1665   1          P3 &= ~USE_P3;
1666   1          P35 = 1;
1667   1      
1668   1          GPIO_setOpenDrainOutput(3, 5);//  P6
1669   1          GPIO_setPushPullupOutput(3, 6);// P7
1670   1          P0 &= ~USE_P0;
1671   1          P2 &= ~(USE_P2 >> 4);           // enable P2.0~P2.3, disable P2.4~P2.7
1672   1          P3 &= ~USE_P3;
1673   1          P36 = 1;
1674   1      
1675   1          GPIO_setOpenDrainOutput(3, 6);//  P7
1676   1          GPIO_setPushPullupOutput(3, 7);// P8
1677   1          P0 &= ~USE_P0;
1678   1          P2 &= ~(USE_P2 >> 4);           // enable P2.0~P2.3, disable P2.4~P2.7
1679   1          P3 &= ~USE_P3;
1680   1          P37 = 1;
1681   1      
1682   1          GPIO_setOpenDrainOutput(3, 7);//  P8
1683   1          GPIO_setPushPullupOutput(2, 0);// P9
1684   1          P0 &= ~USE_P0;
1685   1          P2 &= ~(USE_P2 >> 4);           // enable P2.0~P2.3, disable P2.4~P2.7
1686   1          P3 &= ~USE_P3;
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 36  

1687   1          P20 = 1;
1688   1      
1689   1          GPIO_setOpenDrainOutput(2, 0);//  P9
1690   1          GPIO_setPushPullupOutput(2, 1);//P10
1691   1          P2 &= ~(USE_P2 >> 4);           // enable P2.0~P2.3, disable P2.4~P2.7
1692   1          P0 &= ~USE_P0;
1693   1          P3 &= ~USE_P3;
1694   1          P21 = 1;
1695   1      
1696   1          GPIO_setOpenDrainOutput(2, 1);// P10
1697   1          GPIO_setPushPullupOutput(2, 2);//P11
1698   1          P2 &= ~(USE_P2 >> 4);           // enable P2.0~P2.3, disable P2.4~P2.7
1699   1          P0 &= ~USE_P0;
1700   1          P3 &= ~USE_P3;
1701   1          P22 = 1;
1702   1      
1703   1          GPIO_setOpenDrainOutput(2, 2);// P11
1704   1          GPIO_setPushPullupOutput(2, 3);//P12
1705   1          P2 &= ~(USE_P2 >> 4);           // enable P2.0~P2.3, disable P2.4~P2.7
1706   1          P0 &= ~USE_P0;
1707   1          P3 &= ~USE_P3;
1708   1          P23 = 1;
1709   1      
1710   1          GPIO_setOpenDrainOutput(2, 3);
1711   1          P23 = 0;
1712   1          return;
1713   1      }
1714          
1715          void LED_twoBytes_test1(void)
1716          {
1717   1          GPIO_setHighResistanceInput(0, 0);
1718   1          GPIO_setOpenDrainOutput(3, 3);
1719   1          P2 = ~(USE_P2 << 4);// enable P2.4~P2.7
1720   1          P1 = ~USE_P1;       // enable P1.0~P1.7
1721   1          P33 = 1;
1722   1      
1723   1          GPIO_setOpenDrainOutput(3, 3);//  P0
1724   1          GPIO_setPushPullupOutput(0, 0);// P1
1725   1          P0 |= USE_P0;       // disable P0.0~P0.3
1726   1          P3 |= USE_P3;       // disable P3.3
1727   1          P00 = 1;
1728   1      
1729   1          GPIO_setOpenDrainOutput(0, 0);//  P1
1730   1          GPIO_setPushPullupOutput(0, 1);// P2
1731   1          P0 |= USE_P0;
1732   1          P3 |= USE_P3;
1733   1          P01 = 1;
1734   1      
1735   1          GPIO_setOpenDrainOutput(0, 1);//  P2
1736   1          GPIO_setPushPullupOutput(0, 2);// P3
1737   1          P0 |= USE_P0;
1738   1          P3 |= USE_P3;
1739   1          P02 = 1;
1740   1      
1741   1          GPIO_setOpenDrainOutput(0, 2);//  P3
1742   1          GPIO_setPushPullupOutput(0, 3);// P4
1743   1          P0 |= USE_P0;
1744   1          P3 |= USE_P3;
1745   1          P03 = 1;
1746   1      
1747   1          GPIO_setOpenDrainOutput(0, 3);//  P4
1748   1          GPIO_setPushPullupOutput(3, 4);// P5
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 37  

1749   1          P0 |= USE_P0;
1750   1          P3 |= USE_P3;
1751   1          P34 = 1;
1752   1      
1753   1      
1754   1          GPIO_setOpenDrainOutput(3, 4);//  P5
1755   1          GPIO_setPushPullupOutput(3, 5);// P6
1756   1          P0 |= USE_P0;
1757   1          P3 |= USE_P3;
1758   1          P35 = 1;
1759   1      
1760   1      
1761   1          GPIO_setOpenDrainOutput(3, 5);//  P6
1762   1          GPIO_setPushPullupOutput(3, 6);// P7
1763   1          P0 |= USE_P0;
1764   1          P3 |= USE_P3;
1765   1          P36 = 1;
1766   1      
1767   1      
1768   1          GPIO_setOpenDrainOutput(3, 6);//  P7
1769   1          GPIO_setPushPullupOutput(3, 7);// P8
1770   1          P0 |= USE_P0;
1771   1          P3 |= USE_P3;
1772   1          P37 = 1;
1773   1      
1774   1      
1775   1          GPIO_setOpenDrainOutput(3, 7);//  P8
1776   1          GPIO_setPushPullupOutput(2, 0);// P9
1777   1          P0 |= USE_P0;
1778   1          P3 |= USE_P3;
1779   1          P20 = 1;
1780   1      
1781   1      
1782   1          GPIO_setOpenDrainOutput(2, 0);//  P9
1783   1          GPIO_setPushPullupOutput(2, 1);//P10
1784   1          P0 |= USE_P0;
1785   1          P3 |= USE_P3;
1786   1          P21 = 1;
1787   1      
1788   1      
1789   1          GPIO_setOpenDrainOutput(2, 1);// P10
1790   1          GPIO_setPushPullupOutput(2, 2);//P11
1791   1          P0 |= USE_P0;
1792   1          P3 |= USE_P3;
1793   1          P22 = 1;
1794   1      
1795   1      
1796   1          GPIO_setOpenDrainOutput(2, 2);// P11
1797   1          GPIO_setPushPullupOutput(2, 3);//P12
1798   1          P0 |= USE_P0;
1799   1          P3 |= (USE_P3 << 1);
1800   1          P33 = 1;
1801   1          P23 = 1;
1802   1      
1803   1          GPIO_setOpenDrainOutput(2, 3);
1804   1          P23 = 0;
1805   1          return;
1806   1      }
1807          
1808          void LED_twoBytes_test2(void)
1809          {
1810   1          GPIO_setOpenDrainOutput(3, 3);
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 38  

1811   1          GPIO_setOpenDrainOutput(2, 7);
1812   1          P33 = 1;
1813   1          P1 = USE_P1;         // disable P1.0~P1.7
1814   1          P3 &= ~(USE_P3 << 1);// enable P3.4~P3.7
1815   1          P2 = ~(USE_P2 >> 4); // enable P2.0~P2.3
1816   1          P0 &= ~USE_P0;       // disable P0.1~P0.3
1817   1      
1818   1      
1819   1          GPIO_setOpenDrainOutput(2, 3);// P12
1820   1          GPIO_setPushPullupOutput(1, 0);//P13
1821   1          P10 = 1;
1822   1      
1823   1          GPIO_setOpenDrainOutput(1, 0);// P13
1824   1          GPIO_setPushPullupOutput(1, 1);//P14
1825   1          P1 = USE_P1;        // P1.0~P1.7
1826   1          P11 = 1;
1827   1      
1828   1          GPIO_setOpenDrainOutput(1, 1);// P14
1829   1          GPIO_setPushPullupOutput(1, 2);//P15
1830   1          P1 = USE_P1;        // P1.0~P1.7
1831   1          P12 = 1;
1832   1      
1833   1          GPIO_setOpenDrainOutput(1, 2);// P15
1834   1          GPIO_setPushPullupOutput(1, 3);//P16
1835   1          P1 = USE_P1;        // P1.0~P1.7
1836   1          P13 = 1;
1837   1      
1838   1          GPIO_setOpenDrainOutput(1, 3);// P16
1839   1          GPIO_setPushPullupOutput(1, 4);//P17
1840   1          P1 = USE_P1;        // P1.0~P1.7
1841   1          P14 = 1;
1842   1      
1843   1          GPIO_setOpenDrainOutput(1, 4);// P17
1844   1          GPIO_setPushPullupOutput(1, 5);//P18
1845   1          P1 = USE_P1;        // P1.0~P1.7
1846   1          P15 = 1;
1847   1      
1848   1          GPIO_setOpenDrainOutput(1, 5);// P18
1849   1          GPIO_setPushPullupOutput(1, 6);//P19
1850   1          P1 = USE_P1;        // P1.0~P1.7
1851   1          P16 = 1;
1852   1      
1853   1          GPIO_setOpenDrainOutput(1, 6);// P19
1854   1          GPIO_setPushPullupOutput(1, 7);//P20
1855   1          P1 = USE_P1;        // P1.0~P1.7
1856   1          P17 = 1;
1857   1      
1858   1          GPIO_setOpenDrainOutput(1, 7);// P20
1859   1          GPIO_setPushPullupOutput(2, 4);//P21
1860   1          P1 = USE_P1;        // P1.0~P1.7
1861   1          P24 = 1;
1862   1      
1863   1          GPIO_setOpenDrainOutput(2, 4);// P21
1864   1          GPIO_setPushPullupOutput(2, 5);//P22
1865   1          P2 = ~(USE_P2 >> 4);// P2.0~P2.3
1866   1          P25 = 1;
1867   1      
1868   1          GPIO_setOpenDrainOutput(2, 5);// P22
1869   1          GPIO_setPushPullupOutput(2, 6);//P23
1870   1          P2 = ~(USE_P2 >> 4);// P2.0~P2.3
1871   1          P26 = 1;
1872   1      
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 39  

1873   1          GPIO_setOpenDrainOutput(2, 6);// P23
1874   1          GPIO_setPushPullupOutput(2, 7);//P24
1875   1          P2 = ~(USE_P2 >> 4);// P2.0~P2.3
1876   1          P27 = 1;
1877   1      
1878   1          GPIO_setOpenDrainOutput(2, 7);// P24
1879   1          P2 = ~(USE_P2 >> 4);// P2.0~P2.3
1880   1      
1881   1          return;
1882   1      }
1883          
1884          void LED_twoBytes_test3(void)
1885          {
1886   1          P0 &= USE_P0;     // disable P0.0~P0.3
1887   1          P33 = 1;
1888   1          P3 &= USE_P3 << 1;// enable P3.3, disable P3.4~P3.7
1889   1      
1890   1      
1891   1          GPIO_setOpenDrainOutput(3, 3);//  P0
1892   1          GPIO_setOpenDrainOutput(2, 3);// P12
1893   1          GPIO_setPushPullupOutput(1, 0);//P13
1894   1          P2 = USE_P2 >> 4; // enable P2.4~P2.7
1895   1          P1 = ~USE_P1;     // enable P1.0~P1.7
1896   1          P10 = 1;
1897   1      
1898   1          GPIO_setOpenDrainOutput(1, 0);// P13
1899   1          GPIO_setPushPullupOutput(1, 1);//P14
1900   1          P2 = USE_P2 >> 4; // enable P2.4~P2.7
1901   1          P1 = ~USE_P1;     // enable P1.0~P1.7
1902   1          P10 = 0;
1903   1          P11 = 1;
1904   1      
1905   1          GPIO_setOpenDrainOutput(1, 1);// P14
1906   1          GPIO_setPushPullupOutput(1, 2);//P15
1907   1          P2 = USE_P2 >> 4; // enable P2.4~P2.7
1908   1          P1 = ~USE_P1;     // enable P1.0~P1.7
1909   1          P11 = 0;
1910   1          P12 = 1;
1911   1      
1912   1          GPIO_setOpenDrainOutput(1, 2);// P15
1913   1          GPIO_setPushPullupOutput(1, 3);//P16
1914   1          P2 = USE_P2 >> 4; // enable P2.4~P2.7
1915   1          P1 = ~USE_P1;     // enable P1.0~P1.7
1916   1          P12 = 0;
1917   1          P13 = 1;
1918   1      
1919   1          GPIO_setOpenDrainOutput(1, 3);// P16
1920   1          GPIO_setPushPullupOutput(1, 4);//P17
1921   1          P2 = USE_P2 >> 4; // enable P2.4~P2.7
1922   1          P1 = ~USE_P1;     // enable P1.0~P1.7
1923   1          P13 = 0;
1924   1          P14 = 1;
1925   1      
1926   1          GPIO_setOpenDrainOutput(1, 4);// P17
1927   1          GPIO_setPushPullupOutput(1, 5);//P18
1928   1          P2 = USE_P2 >> 4; // enable P2.4~P2.7
1929   1          P1 = ~USE_P1;     // enable P1.0~P1.7
1930   1          P14 = 0;
1931   1          P15 = 1;
1932   1      
1933   1          GPIO_setOpenDrainOutput(1, 5);// P18
1934   1          GPIO_setPushPullupOutput(1, 6);//P19
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 40  

1935   1          P2 = USE_P2 >> 4; // enable P2.4~P2.7
1936   1          P1 = ~USE_P1;     // enable P1.0~P1.7
1937   1          P15 = 0;
1938   1          P16 = 1;
1939   1      
1940   1          GPIO_setOpenDrainOutput(1, 6);// P19
1941   1          GPIO_setPushPullupOutput(1, 7);//P20
1942   1          P2 = USE_P2 >> 4; // enable P2.4~P2.7
1943   1          P1 = ~USE_P1;     // enable P1.0~P1.7
1944   1          P16 = 0;
1945   1          P17 = 1;
1946   1      
1947   1          GPIO_setOpenDrainOutput(1, 7);// P20
1948   1          GPIO_setPushPullupOutput(2, 4);//P21
1949   1          P2 = USE_P2 >> 4; // enable P2.4~P2.7
1950   1          P1 = ~USE_P1;     // enable P1.0~P1.7
1951   1          P17 = 0;
1952   1          P24 = 1;
1953   1      
1954   1          GPIO_setOpenDrainOutput(2, 4);// P21
1955   1          GPIO_setPushPullupOutput(2, 5);//P22
1956   1          P2 = USE_P2 >> 4; // enable P2.4~P2.7
1957   1          P1 = ~USE_P1;     // enable P1.0~P1.7
1958   1          P24 = 0;
1959   1          P25 = 1;
1960   1      
1961   1          GPIO_setOpenDrainOutput(2, 5);// P22
1962   1          GPIO_setPushPullupOutput(2, 6);//P23
1963   1          P2 = USE_P2 >> 4; // enable P2.4~P2.7
1964   1          P1 = ~USE_P1;     // enable P1.0~P1.7
1965   1          P25 = 0;
1966   1          P26 = 1;
1967   1      
1968   1          GPIO_setOpenDrainOutput(2, 6);// P23
1969   1          GPIO_setPushPullupOutput(2, 7);//P24
1970   1          P2 = USE_P2 >> 4; // enable P2.4~P2.7
1971   1          P1 = ~USE_P1;     // enable P1.0~P1.7
1972   1          P26 = 0;
1973   1          P27 = 1;
1974   1      
1975   1          GPIO_setOpenDrainOutput(2, 7);
1976   1          P27 = 0;
1977   1          return;
1978   1      }
1979          #endif // LED_DEBUG
1980          
1981          /// @brief LEDÁÇπÈòµ0ÊòæÁ§∫
1982          /// @param strData ÊñáÂ≠óÊòæÁ§∫Á†Å([2][12])
1983          /// @param bytes ËØ•ÊñáÂ≠óÊâÄÂç†Â≠óËäÇ‰Ωç
1984          /// @param arrLen ÊòæÁ§∫Á†ÅÈïøÂ∫¶
1985          void LED_screen0_test(const unsigned char(*strData)[12],
1986                                const unsigned char bytes,
1987                                const unsigned char arrLen)
1988          {
1989   1          unsigned char p0_data = USE_P0,
1990   1              p1_data = USE_P1,
1991   1              p2_data = USE_P2,
1992   1              p3_data = USE_P3,
1993   1              pos = 0x00,
1994   1              bytePos = 0x00;
1995   1          P0 = p0_data;
1996   1          P1 = p1_data;                   // disable P1.0~P1.7
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 41  

1997   1          P2 = p2_data;
1998   1          P3 = p3_data;
1999   1      
2000   1          if ( arrLen < MIN_ARR_LEN || strData == NULL)// ËæìÂÖ•ÊòæÁ§∫Á†ÅÈïøÂ∫¶‰∏çË∂≥ÊàñÊåáÈíà‰∏∫Á©∫
2001   1              return;
2002   1      #if 0
              /***************************** P1 *************************************** */
                  if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P8(P37)
                      BIT_SET_ZERO(p3_data, 7);
                  if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P7(P36)
                      BIT_SET_ZERO(p3_data, 6);
                  if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P6(P35)
                      BIT_SET_ZERO(p3_data, 5);
                  if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P5(P34)
                      BIT_SET_ZERO(p3_data, 4);
                  if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P4(P03)
                      BIT_SET_ZERO(p0_data, 3);
                  if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P3(P02)
                      BIT_SET_ZERO(p0_data, 2);
                  if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P2(P01) value
                      BIT_SET_ZERO(p0_data, 1);
                  if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P0(P33)
                      BIT_SET_ZERO(p3_data, 3);
              
                  if ( (FIND_BIT(strData[bytePos][pos + 1], THIRD_BIT)) )// check P12(P23)
                      BIT_SET_ZERO(p2_data, 3);
                  if ( (FIND_BIT(strData[bytePos][pos + 1], SECOND_BIT)) )// check P11(P22)
                      BIT_SET_ZERO(p2_data, 2);
                  if ( (FIND_BIT(strData[bytePos][pos + 1], FIRST_BIT)) )// check P10(P21)
                      BIT_SET_ZERO(p2_data, 1);
                  if ( (FIND_BIT(strData[bytePos][pos + 1], ZEROTH_BIT)) )// check P9(P20)
                      BIT_SET_ZERO(p2_data, 0);
                  GPIO_setOpenDrainOutput(3, 3);//  P0
                  GPIO_setPushPullupOutput(0, 0);// P1
                  P0 = p0_data;
                  P2 = p2_data;
                  P3 = p3_data;
                  P00 = 1;
              
              /***************************** P2 *************************************** */
                  pos += 2;
                  p0_data = USE_P0;
                  p1_data = USE_P1;
                  p2_data = USE_P2;
                  p3_data = USE_P3;
                  if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P8(P37)
                      BIT_SET_ZERO(p3_data, 7);
                  if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P7(P36)
                      BIT_SET_ZERO(p3_data, 6);
                  if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P6(P35)
                      BIT_SET_ZERO(p3_data, 5);
                  if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P5(P34)
                      BIT_SET_ZERO(p3_data, 4);
                  if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P4(P03)
                      BIT_SET_ZERO(p0_data, 3);
                  if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P3(P02)
                      BIT_SET_ZERO(p0_data, 2);
                  if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P0(P33)
                      BIT_SET_ZERO(p3_data, 3);
                  if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P1(P00) value
                      BIT_SET_ZERO(p0_data, 0);
              
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 42  

                  if ( (FIND_BIT(strData[bytePos][pos + 1], THIRD_BIT)) )// check P12(P23)
                      BIT_SET_ZERO(p2_data, 3);
                  if ( (FIND_BIT(strData[bytePos][pos + 1], SECOND_BIT)) )// check P11(P22)
                      BIT_SET_ZERO(p2_data, 2);
                  if ( (FIND_BIT(strData[bytePos][pos + 1], FIRST_BIT)) )// check P10(P21)
                      BIT_SET_ZERO(p2_data, 1);
                  if ( (FIND_BIT(strData[bytePos][pos + 1], ZEROTH_BIT)) )// check P9(P20)
                      BIT_SET_ZERO(p2_data, 0);
                  GPIO_setOpenDrainOutput(0, 0);//  P1
                  GPIO_setPushPullupOutput(0, 1);// P2
                  P0 = p0_data;
                  P2 = p2_data;
                  P3 = p3_data;
                  P01 = 1;
              
              /***************************** P3 *************************************** */
                  pos += 2;
                  p0_data = USE_P0;
                  p1_data = USE_P1;
                  p2_data = USE_P2;
                  p3_data = USE_P3;
                  if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P8(P37)
                      BIT_SET_ZERO(p3_data, 7);
                  if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P7(P36)
                      BIT_SET_ZERO(p3_data, 6);
                  if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P6(P35)
                      BIT_SET_ZERO(p3_data, 5);
                  if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P5(P34)
                      BIT_SET_ZERO(p3_data, 4);
                  if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P4(P03)
                      BIT_SET_ZERO(p0_data, 3);
                  if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P0(P33)
                      BIT_SET_ZERO(p3_data, 3);
                  if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P2(P01)
                      BIT_SET_ZERO(p0_data, 1);
                  if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P1(P00) value
                      BIT_SET_ZERO(p0_data, 0);
              
                  if ( (FIND_BIT(strData[bytePos][pos + 1], THIRD_BIT)) )// check P12(P23)
                      BIT_SET_ZERO(p2_data, 3);
                  if ( (FIND_BIT(strData[bytePos][pos + 1], SECOND_BIT)) )// check P11(P22)
                      BIT_SET_ZERO(p2_data, 2);
                  if ( (FIND_BIT(strData[bytePos][pos + 1], FIRST_BIT)) )// check P10(P21)
                      BIT_SET_ZERO(p2_data, 1);
                  if ( (FIND_BIT(strData[bytePos][pos + 1], ZEROTH_BIT)) )// check P9(P20)
                      BIT_SET_ZERO(p2_data, 0);
                  GPIO_setOpenDrainOutput(0, 1);//  P2
                  GPIO_setPushPullupOutput(0, 2);// P3
                  P0 = p0_data;
                  P2 = p2_data;
                  P3 = p3_data;
                  P02 = 1;
              
              /***************************** P4 *************************************** */
                  pos += 2;
                  p0_data = USE_P0;
                  p1_data = USE_P1;
                  p2_data = USE_P2;
                  p3_data = USE_P3;
                  if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P8(P37)
                      BIT_SET_ZERO(p3_data, 7);
                  if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P7(P36)
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 43  

                      BIT_SET_ZERO(p3_data, 6);
                  if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P6(P35)
                      BIT_SET_ZERO(p3_data, 5);
                  if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P5(P34)
                      BIT_SET_ZERO(p3_data, 4);
                  if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P0(P33)
                      BIT_SET_ZERO(p3_data, 3);
                  if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P3(P02)
                      BIT_SET_ZERO(p0_data, 2);
                  if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P2(P01)
                      BIT_SET_ZERO(p0_data, 1);
                  if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P1(P00) value
                      BIT_SET_ZERO(p0_data, 0);
              
                  if ( (FIND_BIT(strData[bytePos][pos + 1], THIRD_BIT)) )// check P12(P23)
                      BIT_SET_ZERO(p2_data, 3);
                  if ( (FIND_BIT(strData[bytePos][pos + 1], SECOND_BIT)) )// check P11(P22)
                      BIT_SET_ZERO(p2_data, 2);
                  if ( (FIND_BIT(strData[bytePos][pos + 1], FIRST_BIT)) )// check P10(P21)
                      BIT_SET_ZERO(p2_data, 1);
                  if ( (FIND_BIT(strData[bytePos][pos + 1], ZEROTH_BIT)) )// check P9(P20)
                      BIT_SET_ZERO(p2_data, 0);
                  GPIO_setOpenDrainOutput(0, 2);//  P3
                  GPIO_setPushPullupOutput(0, 3);// P4
                  P0 = p0_data;
                  P2 = p2_data;
                  P3 = p3_data;
                  P03 = 1;
              
              /***************************** P5 *************************************** */
                  pos += 2;
                  p0_data = USE_P0;
                  p1_data = USE_P1;
                  p2_data = USE_P2;
                  p3_data = USE_P3;
                  if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P8(P37)
                      BIT_SET_ZERO(p3_data, 7);
                  if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P7(P36)
                      BIT_SET_ZERO(p3_data, 6);
                  if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P6(P35)
                      BIT_SET_ZERO(p3_data, 5);
                  if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P0(P33)
                      BIT_SET_ZERO(p3_data, 3);
                  if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P4(P03)
                      BIT_SET_ZERO(p0_data, 3);
                  if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P3(P02)
                      BIT_SET_ZERO(p0_data, 2);
                  if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P2(P01)
                      BIT_SET_ZERO(p0_data, 1);
                  if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P1(P00) value
                      BIT_SET_ZERO(p0_data, 0);
              
                  if ( (FIND_BIT(strData[bytePos][pos + 1], THIRD_BIT)) )// check P12(P23)
                      BIT_SET_ZERO(p2_data, 3);
                  if ( (FIND_BIT(strData[bytePos][pos + 1], SECOND_BIT)) )// check P11(P22)
                      BIT_SET_ZERO(p2_data, 2);
                  if ( (FIND_BIT(strData[bytePos][pos + 1], FIRST_BIT)) )// check P10(P21)
                      BIT_SET_ZERO(p2_data, 1);
                  if ( (FIND_BIT(strData[bytePos][pos + 1], ZEROTH_BIT)) )// check P9(P20)
                      BIT_SET_ZERO(p2_data, 0);
                  GPIO_setOpenDrainOutput(0, 3);//  P4
                  GPIO_setPushPullupOutput(3, 4);// P5
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 44  

                  P0 = p0_data;
                  P2 = p2_data;
                  P3 = p3_data;
                  P34 = 1;
              
              /***************************** P6 *************************************** */
                  pos += 2;
                  p0_data = USE_P0;
                  p1_data = USE_P1;
                  p2_data = USE_P2;
                  p3_data = USE_P3;
                  if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P8(P37)
                      BIT_SET_ZERO(p3_data, 7);
                  if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P7(P36)
                      BIT_SET_ZERO(p3_data, 6);
                  if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P0(P33)
                      BIT_SET_ZERO(p3_data, 3);
                  if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P5(P34)
                      BIT_SET_ZERO(p3_data, 4);
                  if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P4(P03)
                      BIT_SET_ZERO(p0_data, 3);
                  if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P3(P02)
                      BIT_SET_ZERO(p0_data, 2);
                  if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P2(P01)
                      BIT_SET_ZERO(p0_data, 1);
                  if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P1(P00) value
                      BIT_SET_ZERO(p0_data, 0);
              
                  if ( (FIND_BIT(strData[bytePos][pos + 1], THIRD_BIT)) )// check P12(P23)
                      BIT_SET_ZERO(p2_data, 3);
                  if ( (FIND_BIT(strData[bytePos][pos + 1], SECOND_BIT)) )// check P11(P22)
                      BIT_SET_ZERO(p2_data, 2);
                  if ( (FIND_BIT(strData[bytePos][pos + 1], FIRST_BIT)) )// check P10(P21)
                      BIT_SET_ZERO(p2_data, 1);
                  if ( (FIND_BIT(strData[bytePos][pos + 1], ZEROTH_BIT)) )// check P9(P20)
                      BIT_SET_ZERO(p2_data, 0);
                  GPIO_setOpenDrainOutput(3, 4);//  P5
                  GPIO_setPushPullupOutput(3, 5);// P6
                  P0 = p0_data;
                  P2 = p2_data;
                  P3 = p3_data;
                  P35 = 1;
              
              /***************************** P7 *************************************** */
                  pos += 2;
                  if ( pos >= arrLen )
                  {
                      bytePos++;
                      pos = 0;
                  }
                  p0_data = USE_P0;
                  p1_data = USE_P1;
                  p2_data = USE_P2;
                  p3_data = USE_P3;
                  if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P8(P37)
                      BIT_SET_ZERO(p3_data, 7);
                  if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P0(P33)
                      BIT_SET_ZERO(p3_data, 3);
                  if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P6(P35)
                      BIT_SET_ZERO(p3_data, 5);
                  if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P5(P34)
                      BIT_SET_ZERO(p3_data, 4);
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 45  

                  if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P4(P03)
                      BIT_SET_ZERO(p0_data, 3);
                  if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P3(P02)
                      BIT_SET_ZERO(p0_data, 2);
                  if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P2(P01)
                      BIT_SET_ZERO(p0_data, 1);
                  if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P1(P00) value
                      BIT_SET_ZERO(p0_data, 0);
              
                  if ( (FIND_BIT(strData[bytePos][pos + 1], THIRD_BIT)) )// check P12(P23)
                      BIT_SET_ZERO(p2_data, 3);
                  if ( (FIND_BIT(strData[bytePos][pos + 1], SECOND_BIT)) )// check P11(P22)
                      BIT_SET_ZERO(p2_data, 2);
                  if ( (FIND_BIT(strData[bytePos][pos + 1], FIRST_BIT)) )// check P10(P21)
                      BIT_SET_ZERO(p2_data, 1);
                  if ( (FIND_BIT(strData[bytePos][pos + 1], ZEROTH_BIT)) )// check P9(P20)
                      BIT_SET_ZERO(p2_data, 0);
                  GPIO_setOpenDrainOutput(3, 5);//  P6
                  GPIO_setPushPullupOutput(3, 6);// P7
                  P0 = p0_data;
                  P2 = p2_data;
                  P3 = p3_data;
                  P36 = 1;
              
              /***************************** P8 *************************************** */
                  pos += 2;
                  p0_data = USE_P0;
                  p1_data = USE_P1;
                  p2_data = USE_P2;
                  p3_data = USE_P3;
                  if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P0(P33)
                      BIT_SET_ZERO(p3_data, 3);
                  if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P7(P36)
                      BIT_SET_ZERO(p3_data, 6);
                  if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P6(P35)
                      BIT_SET_ZERO(p3_data, 5);
                  if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P5(P34)
                      BIT_SET_ZERO(p3_data, 4);
                  if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P4(P03)
                      BIT_SET_ZERO(p0_data, 3);
                  if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P3(P02)
                      BIT_SET_ZERO(p0_data, 2);
                  if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P2(P01)
                      BIT_SET_ZERO(p0_data, 1);
                  if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P1(P00) value
                      BIT_SET_ZERO(p0_data, 0);
              
                  if ( (FIND_BIT(strData[bytePos][pos + 1], THIRD_BIT)) )// check P12(P23)
                      BIT_SET_ZERO(p2_data, 3);
                  if ( (FIND_BIT(strData[bytePos][pos + 1], SECOND_BIT)) )// check P11(P22)
                      BIT_SET_ZERO(p2_data, 2);
                  if ( (FIND_BIT(strData[bytePos][pos + 1], FIRST_BIT)) )// check P10(P21)
                      BIT_SET_ZERO(p2_data, 1);
                  if ( (FIND_BIT(strData[bytePos][pos + 1], ZEROTH_BIT)) )// check P9(P20)
                      BIT_SET_ZERO(p2_data, 0);
                  GPIO_setOpenDrainOutput(3, 6);//  P7
                  GPIO_setPushPullupOutput(3, 7);// P8
                  P0 = p0_data;
                  P2 = p2_data;
                  P3 = p3_data;
                  P37 = 1;
              
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 46  

              /***************************** P9 *************************************** */
                  pos += 2;
                  p0_data = USE_P0;
                  p1_data = USE_P1;
                  p2_data = USE_P2;
                  p3_data = USE_P3;
                  if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P8(P37)
                      BIT_SET_ZERO(p3_data, 7);
                  if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P7(P36)
                      BIT_SET_ZERO(p3_data, 6);
                  if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P6(P35)
                      BIT_SET_ZERO(p3_data, 5);
                  if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P5(P34)
                      BIT_SET_ZERO(p3_data, 4);
                  if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P4(P03)
                      BIT_SET_ZERO(p0_data, 3);
                  if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P3(P02)
                      BIT_SET_ZERO(p0_data, 2);
                  if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P2(P01)
                      BIT_SET_ZERO(p0_data, 1);
                  if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P1(P00) value
                      BIT_SET_ZERO(p0_data, 0);
              
                  if ( (FIND_BIT(strData[bytePos][pos + 1], THIRD_BIT)) )// check P12(P23)
                      BIT_SET_ZERO(p2_data, 3);
                  if ( (FIND_BIT(strData[bytePos][pos + 1], SECOND_BIT)) )// check P11(P22)
                      BIT_SET_ZERO(p2_data, 2);
                  if ( (FIND_BIT(strData[bytePos][pos + 1], FIRST_BIT)) )// check P10(P21)
                      BIT_SET_ZERO(p2_data, 1);
                  if ( (FIND_BIT(strData[bytePos][pos + 1], ZEROTH_BIT)) )// check P0(P33)
                      BIT_SET_ZERO(p3_data, 3);
                  GPIO_setOpenDrainOutput(3, 7);//  P8
                  GPIO_setPushPullupOutput(2, 0);// P9
                  P0 = p0_data;
                  P2 = p2_data;
                  P3 = p3_data;
                  P20 = 1;
              
              /***************************** P10 *************************************** */
                  pos += 2;
                  p0_data = USE_P0;
                  p1_data = USE_P1;
                  p2_data = USE_P2;
                  p3_data = USE_P3;
                  if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P8(P37)
                      BIT_SET_ZERO(p3_data, 7);
                  if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P7(P36)
                      BIT_SET_ZERO(p3_data, 6);
                  if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P6(P35)
                      BIT_SET_ZERO(p3_data, 5);
                  if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P5(P34)
                      BIT_SET_ZERO(p3_data, 4);
                  if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P4(P03)
                      BIT_SET_ZERO(p0_data, 3);
                  if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P3(P02)
                      BIT_SET_ZERO(p0_data, 2);
                  if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P2(P01)
                      BIT_SET_ZERO(p0_data, 1);
                  if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P1(P00) value
                      BIT_SET_ZERO(p0_data, 0);
              
                  if ( (FIND_BIT(strData[bytePos][pos + 1], THIRD_BIT)) )// check P12(P23)
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 47  

                      BIT_SET_ZERO(p2_data, 3);
                  if ( (FIND_BIT(strData[bytePos][pos + 1], SECOND_BIT)) )// check P11(P22)
                      BIT_SET_ZERO(p2_data, 2);
                  if ( (FIND_BIT(strData[bytePos][pos + 1], FIRST_BIT)) )// check P0(P33)
                      BIT_SET_ZERO(p3_data, 3);
                  if ( (FIND_BIT(strData[bytePos][pos + 1], ZEROTH_BIT)) )// check P9(P20)
                      BIT_SET_ZERO(p2_data, 0);
                  GPIO_setOpenDrainOutput(2, 0);//  P9
                  GPIO_setPushPullupOutput(2, 1);//P10
                  P0 = p0_data;
                  P2 = p2_data;
                  P3 = p3_data;
                  P21 = 1;
              
              /***************************** P11 *************************************** */
                  pos += 2;
                  p0_data = USE_P0;
                  p1_data = USE_P1;
                  p2_data = USE_P2;
                  p3_data = USE_P3;
                  if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P8(P37)
                      BIT_SET_ZERO(p3_data, 7);
                  if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P7(P36)
                      BIT_SET_ZERO(p3_data, 6);
                  if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P6(P35)
                      BIT_SET_ZERO(p3_data, 5);
                  if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P5(P34)
                      BIT_SET_ZERO(p3_data, 4);
                  if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P4(P03)
                      BIT_SET_ZERO(p0_data, 3);
                  if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P3(P02)
                      BIT_SET_ZERO(p0_data, 2);
                  if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P2(P01)
                      BIT_SET_ZERO(p0_data, 1);
                  if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P1(P00) value
                      BIT_SET_ZERO(p0_data, 0);
              
                  if ( (FIND_BIT(strData[bytePos][pos + 1], THIRD_BIT)) )// check P12(P23)
                      BIT_SET_ZERO(p2_data, 3);
                  if ( (FIND_BIT(strData[bytePos][pos + 1], SECOND_BIT)) )// check P0(P33)
                      BIT_SET_ZERO(p3_data, 3);
                  if ( (FIND_BIT(strData[bytePos][pos + 1], FIRST_BIT)) )// check P10(P21)
                      BIT_SET_ZERO(p2_data, 1);
                  if ( (FIND_BIT(strData[bytePos][pos + 1], ZEROTH_BIT)) )// check P9(P20)
                      BIT_SET_ZERO(p2_data, 0);
                  GPIO_setOpenDrainOutput(2, 1);// P10
                  GPIO_setPushPullupOutput(2, 2);//P11
                  P0 = p0_data;
                  P2 = p2_data;
                  P3 = p3_data;
                  P22 = 1;
              
              /***************************** P12 *************************************** */
                  pos += 2;
                  p0_data = USE_P0;
                  p1_data = USE_P1;
                  p2_data = USE_P2;
                  p3_data = USE_P3;
                  if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P8(P37)
                      BIT_SET_ZERO(p3_data, 7);
                  if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P7(P36)
                      BIT_SET_ZERO(p3_data, 6);
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 48  

                  if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P6(P35)
                      BIT_SET_ZERO(p3_data, 5);
                  if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P5(P34)
                      BIT_SET_ZERO(p3_data, 4);
                  if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P4(P03)
                      BIT_SET_ZERO(p0_data, 3);
                  if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P3(P02)
                      BIT_SET_ZERO(p0_data, 2);
                  if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P2(P01)
                      BIT_SET_ZERO(p0_data, 1);
                  if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P1(P00) value
                      BIT_SET_ZERO(p0_data, 0);
              
                  if ( (FIND_BIT(strData[bytePos][pos + 1], THIRD_BIT)) )// check P0(P33)
                      BIT_SET_ZERO(p3_data, 3);
                  if ( (FIND_BIT(strData[bytePos][pos + 1], SECOND_BIT)) )// check P11(P22)
                      BIT_SET_ZERO(p2_data, 3);
                  if ( (FIND_BIT(strData[bytePos][pos + 1], FIRST_BIT)) )// check P10(P21)
                      BIT_SET_ZERO(p2_data, 1);
                  if ( (FIND_BIT(strData[bytePos][pos + 1], ZEROTH_BIT)) )// check P9(P20)
                      BIT_SET_ZERO(p2_data, 0);
                  GPIO_setOpenDrainOutput(2, 2);// P11
                  GPIO_setPushPullupOutput(2, 3);//P12
                  P0 = p0_data;
                  P2 = p2_data;
                  P3 = p3_data;
                  P23 = 1;
              #else
2459   1      /***************************** P1 *************************************** */
2460   1          if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P0(P33)
2461   1              BIT_SET_ZERO(p3_data, 3);
2462   1          if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P2(P01) value
2463   1              BIT_SET_ZERO(p0_data, 1);
2464   1          if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P3(P02)
2465   1              BIT_SET_ZERO(p0_data, 2);
2466   1          if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P4(P03)
2467   1              BIT_SET_ZERO(p0_data, 3);
2468   1          if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P5(P34)
2469   1              BIT_SET_ZERO(p3_data, 4);
2470   1          if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P6(P35)
2471   1              BIT_SET_ZERO(p3_data, 5);
2472   1          if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P7(P36)
2473   1              BIT_SET_ZERO(p3_data, 6);
2474   1          if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P8(P37)
2475   1              BIT_SET_ZERO(p3_data, 7);
2476   1      
2477   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SEVENTH_BIT)) )// check P9(P20)
2478   1              BIT_SET_ZERO(p2_data, 0);
2479   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SIXTH_BIT)) )// check P10(P21)
2480   1              BIT_SET_ZERO(p2_data, 1);
2481   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FIFTH_BIT)) )// check P11(P22)
2482   1              BIT_SET_ZERO(p2_data, 2);
2483   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FOURTH_BIT)) )// check P12(P23)
2484   1              BIT_SET_ZERO(p2_data, 3);
2485   1          GPIO_setOpenDrainOutput(3, 3);//  P0
2486   1          GPIO_setPushPullupOutput(0, 0);// P1
2487   1          P0 = p0_data;
2488   1          P2 = p2_data;
2489   1          P3 = p3_data;
2490   1          P00 = 1;
2491   1      
2492   1          /***************************** P2 *************************************** */
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 49  

2493   1          pos += 2;
2494   1          p0_data = USE_P0;
2495   1          p1_data = USE_P1;
2496   1          p2_data = USE_P2;
2497   1          p3_data = USE_P3;
2498   1          if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P1(P00) value
2499   1              BIT_SET_ZERO(p0_data, 0);
2500   1          if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P0(P33)
2501   1              BIT_SET_ZERO(p3_data, 3);
2502   1          if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P3(P02)
2503   1              BIT_SET_ZERO(p0_data, 2);
2504   1          if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P4(P03)
2505   1              BIT_SET_ZERO(p0_data, 3);
2506   1          if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P5(P34)
2507   1              BIT_SET_ZERO(p3_data, 4);
2508   1          if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P6(P35)
2509   1              BIT_SET_ZERO(p3_data, 5);
2510   1          if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P7(P36)
2511   1              BIT_SET_ZERO(p3_data, 6);
2512   1          if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P8(P37)
2513   1              BIT_SET_ZERO(p3_data, 7);
2514   1      
2515   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SEVENTH_BIT)) )// check P9(P20)
2516   1              BIT_SET_ZERO(p2_data, 0);
2517   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SIXTH_BIT)) )// check P10(P21)
2518   1              BIT_SET_ZERO(p2_data, 1);
2519   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FIFTH_BIT)) )// check P11(P22)
2520   1              BIT_SET_ZERO(p2_data, 2);
2521   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FOURTH_BIT)) )// check P12(P23)
2522   1              BIT_SET_ZERO(p2_data, 3);
2523   1          GPIO_setOpenDrainOutput(0, 0);//  P1
2524   1          GPIO_setPushPullupOutput(0, 1);// P2
2525   1          P0 = p0_data;
2526   1          P2 = p2_data;
2527   1          P3 = p3_data;
2528   1          P01 = 1;
2529   1      
2530   1          /***************************** P3 *************************************** */
2531   1          pos += 2;
2532   1          p0_data = USE_P0;
2533   1          p1_data = USE_P1;
2534   1          p2_data = USE_P2;
2535   1          p3_data = USE_P3;
2536   1          if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P1(P00) value
2537   1              BIT_SET_ZERO(p0_data, 0);
2538   1          if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P2(P01)
2539   1              BIT_SET_ZERO(p0_data, 1);
2540   1          if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P0(P33)
2541   1              BIT_SET_ZERO(p3_data, 3);
2542   1          if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P4(P03)
2543   1              BIT_SET_ZERO(p0_data, 3);
2544   1          if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P5(P34)
2545   1              BIT_SET_ZERO(p3_data, 4);
2546   1          if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P6(P35)
2547   1              BIT_SET_ZERO(p3_data, 5);
2548   1          if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P7(P36)
2549   1              BIT_SET_ZERO(p3_data, 6);
2550   1          if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P8(P37)
2551   1              BIT_SET_ZERO(p3_data, 7);
2552   1      
2553   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SEVENTH_BIT)) )// check P9(P20)
2554   1              BIT_SET_ZERO(p2_data, 0);
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 50  

2555   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SIXTH_BIT)) )// check P10(P21)
2556   1              BIT_SET_ZERO(p2_data, 1);
2557   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FIFTH_BIT)) )// check P11(P22)
2558   1              BIT_SET_ZERO(p2_data, 2);
2559   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FOURTH_BIT)) )// check P12(P23)
2560   1              BIT_SET_ZERO(p2_data, 3);
2561   1          GPIO_setOpenDrainOutput(0, 1);//  P2
2562   1          GPIO_setPushPullupOutput(0, 2);// P3
2563   1          P0 = p0_data;
2564   1          P2 = p2_data;
2565   1          P3 = p3_data;
2566   1          P02 = 1;
2567   1      
2568   1          /***************************** P4 *************************************** */
2569   1          pos += 2;
2570   1          p0_data = USE_P0;
2571   1          p1_data = USE_P1;
2572   1          p2_data = USE_P2;
2573   1          p3_data = USE_P3;
2574   1          if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P1(P00) value
2575   1              BIT_SET_ZERO(p0_data, 0);
2576   1          if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P2(P01)
2577   1              BIT_SET_ZERO(p0_data, 1);
2578   1          if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P3(P02)
2579   1              BIT_SET_ZERO(p0_data, 2);
2580   1          if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P0(P33)
2581   1              BIT_SET_ZERO(p3_data, 3);
2582   1          if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P5(P34)
2583   1              BIT_SET_ZERO(p3_data, 4);
2584   1          if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P6(P35)
2585   1              BIT_SET_ZERO(p3_data, 5);
2586   1          if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P7(P36)
2587   1              BIT_SET_ZERO(p3_data, 6);
2588   1          if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P8(P37)
2589   1              BIT_SET_ZERO(p3_data, 7);
2590   1      
2591   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SEVENTH_BIT)) )// check P9(P20)
2592   1              BIT_SET_ZERO(p2_data, 0);
2593   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SIXTH_BIT)) )// check P10(P21)
2594   1              BIT_SET_ZERO(p2_data, 1);
2595   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FIFTH_BIT)) )// check P11(P22)
2596   1              BIT_SET_ZERO(p2_data, 2);
2597   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FOURTH_BIT)) )// check P12(P23)
2598   1              BIT_SET_ZERO(p2_data, 3);
2599   1          GPIO_setOpenDrainOutput(0, 2);//  P3
2600   1          GPIO_setPushPullupOutput(0, 3);// P4
2601   1          P0 = p0_data;
2602   1          P2 = p2_data;
2603   1          P3 = p3_data;
2604   1          P03 = 1;
2605   1      
2606   1          /***************************** P5 *************************************** */
2607   1          pos += 2;
2608   1          p0_data = USE_P0;
2609   1          p1_data = USE_P1;
2610   1          p2_data = USE_P2;
2611   1          p3_data = USE_P3;
2612   1          if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P1(P00) value
2613   1              BIT_SET_ZERO(p0_data, 0);
2614   1          if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P2(P01)
2615   1              BIT_SET_ZERO(p0_data, 1);
2616   1          if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P3(P02)
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 51  

2617   1              BIT_SET_ZERO(p0_data, 2);
2618   1          if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P4(P03)
2619   1              BIT_SET_ZERO(p0_data, 3);
2620   1          if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P0(P33)
2621   1              BIT_SET_ZERO(p3_data, 3);
2622   1          if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P6(P35)
2623   1              BIT_SET_ZERO(p3_data, 5);
2624   1          if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P7(P36)
2625   1              BIT_SET_ZERO(p3_data, 6);
2626   1          if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P8(P37)
2627   1              BIT_SET_ZERO(p3_data, 7);
2628   1      
2629   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SEVENTH_BIT)) )// check P9(P20)
2630   1              BIT_SET_ZERO(p2_data, 0);
2631   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SIXTH_BIT)) )// check P10(P21)
2632   1              BIT_SET_ZERO(p2_data, 1);
2633   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FIFTH_BIT)) )// check P11(P22)
2634   1              BIT_SET_ZERO(p2_data, 2);
2635   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FOURTH_BIT)) )// check P12(P23)
2636   1              BIT_SET_ZERO(p2_data, 3);
2637   1          GPIO_setOpenDrainOutput(0, 3);//  P4
2638   1          GPIO_setPushPullupOutput(3, 4);// P5
2639   1          P0 = p0_data;
2640   1          P2 = p2_data;
2641   1          P3 = p3_data;
2642   1          P34 = 1;
2643   1      
2644   1          /***************************** P6 *************************************** */
2645   1          pos += 2;
2646   1          p0_data = USE_P0;
2647   1          p1_data = USE_P1;
2648   1          p2_data = USE_P2;
2649   1          p3_data = USE_P3;
2650   1          if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P1(P00) value
2651   1              BIT_SET_ZERO(p0_data, 0);
2652   1          if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P2(P01)
2653   1              BIT_SET_ZERO(p0_data, 1);
2654   1          if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P3(P02)
2655   1              BIT_SET_ZERO(p0_data, 2);
2656   1          if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P4(P03)
2657   1              BIT_SET_ZERO(p0_data, 3);
2658   1          if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P5(P34)
2659   1              BIT_SET_ZERO(p3_data, 4);
2660   1          if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P0(P33)
2661   1              BIT_SET_ZERO(p3_data, 3);
2662   1          if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P7(P36)
2663   1              BIT_SET_ZERO(p3_data, 6);
2664   1          if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P8(P37)
2665   1              BIT_SET_ZERO(p3_data, 7);
2666   1      
2667   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SEVENTH_BIT)) )// check P9(P20)
2668   1              BIT_SET_ZERO(p2_data, 0);
2669   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SIXTH_BIT)) )// check P10(P21)
2670   1              BIT_SET_ZERO(p2_data, 1);
2671   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FIFTH_BIT)) )// check P11(P22)
2672   1              BIT_SET_ZERO(p2_data, 2);
2673   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FOURTH_BIT)) )// check P12(P23)
2674   1              BIT_SET_ZERO(p2_data, 3);
2675   1          GPIO_setOpenDrainOutput(3, 4);//  P5
2676   1          GPIO_setPushPullupOutput(3, 5);// P6
2677   1          P0 = p0_data;
2678   1          P2 = p2_data;
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 52  

2679   1          P3 = p3_data;
2680   1          P35 = 1;
2681   1      
2682   1          /***************************** P7 *************************************** */
2683   1          pos += 2;
2684   1          if ( bytes < MIN_BYTES )// Â≠óÁ¨¶Â≠óËäÇÊï∞‰∏çË∂≥, ÁªìÊùüËØ•Â≠óÊòæÁ§∫
2685   1              return;
2686   1          if ( pos >= arrLen )
2687   1          {
2688   2              bytePos++;
2689   2              pos = 0;
2690   2          }
2691   1          p0_data = USE_P0;
2692   1          p1_data = USE_P1;
2693   1          p2_data = USE_P2;
2694   1          p3_data = USE_P3;
2695   1          if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P1(P00) value
2696   1              BIT_SET_ZERO(p0_data, 0);
2697   1          if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P2(P01)
2698   1              BIT_SET_ZERO(p0_data, 1);
2699   1          if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P3(P02)
2700   1              BIT_SET_ZERO(p0_data, 2);
2701   1          if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P4(P03)
2702   1              BIT_SET_ZERO(p0_data, 3);
2703   1          if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P5(P34)
2704   1              BIT_SET_ZERO(p3_data, 4);
2705   1          if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P6(P35)
2706   1              BIT_SET_ZERO(p3_data, 5);
2707   1          if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P0(P33)
2708   1              BIT_SET_ZERO(p3_data, 3);
2709   1          if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P8(P37)
2710   1              BIT_SET_ZERO(p3_data, 7);
2711   1      
2712   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SEVENTH_BIT)) )// check P9(P20)
2713   1              BIT_SET_ZERO(p2_data, 0);
2714   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SIXTH_BIT)) )// check P10(P21)
2715   1              BIT_SET_ZERO(p2_data, 1);
2716   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FIFTH_BIT)) )// check P11(P22)
2717   1              BIT_SET_ZERO(p2_data, 2);
2718   1          if ( (FIND_BIT(strData[bytePos][pos + 1], THIRD_BIT)) )// check P12(P23)
2719   1              BIT_SET_ZERO(p2_data, 3);
2720   1          GPIO_setOpenDrainOutput(3, 5);//  P6
2721   1          GPIO_setPushPullupOutput(3, 6);// P7
2722   1          P0 = p0_data;
2723   1          P2 = p2_data;
2724   1          P3 = p3_data;
2725   1          P36 = 1;
2726   1      
2727   1          /***************************** P8 *************************************** */
2728   1          pos += 2;
2729   1          p0_data = USE_P0;
2730   1          p1_data = USE_P1;
2731   1          p2_data = USE_P2;
2732   1          p3_data = USE_P3;
2733   1          if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P1(P00) value
2734   1              BIT_SET_ZERO(p0_data, 0);
2735   1          if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P2(P01)
2736   1              BIT_SET_ZERO(p0_data, 1);
2737   1          if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P3(P02)
2738   1              BIT_SET_ZERO(p0_data, 2);
2739   1          if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P4(P03)
2740   1              BIT_SET_ZERO(p0_data, 3);
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 53  

2741   1          if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P5(P34)
2742   1              BIT_SET_ZERO(p3_data, 4);
2743   1          if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P6(P35)
2744   1              BIT_SET_ZERO(p3_data, 5);
2745   1          if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P7(P36)
2746   1              BIT_SET_ZERO(p3_data, 6);
2747   1          if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P0(P33)
2748   1              BIT_SET_ZERO(p3_data, 3);
2749   1      
2750   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SEVENTH_BIT)) )// check P9(P20)
2751   1              BIT_SET_ZERO(p2_data, 0);
2752   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SIXTH_BIT)) )// check P10(P21)
2753   1              BIT_SET_ZERO(p2_data, 1);
2754   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FIFTH_BIT)) )// check P11(P22)
2755   1              BIT_SET_ZERO(p2_data, 2);
2756   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FOURTH_BIT)) )// check P12(P23)
2757   1              BIT_SET_ZERO(p2_data, 3);
2758   1          GPIO_setOpenDrainOutput(3, 6);//  P7
2759   1          GPIO_setPushPullupOutput(3, 7);// P8
2760   1          P0 = p0_data;
2761   1          P2 = p2_data;
2762   1          P3 = p3_data;
2763   1          P37 = 1;
2764   1      
2765   1          /***************************** P9 *************************************** */
2766   1          pos += 2;
2767   1          p0_data = USE_P0;
2768   1          p1_data = USE_P1;
2769   1          p2_data = USE_P2;
2770   1          p3_data = USE_P3;
2771   1          if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P1(P00) value
2772   1              BIT_SET_ZERO(p0_data, 0);
2773   1          if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P2(P01)
2774   1              BIT_SET_ZERO(p0_data, 1);
2775   1          if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P3(P02)
2776   1              BIT_SET_ZERO(p0_data, 2);
2777   1          if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P4(P03)
2778   1              BIT_SET_ZERO(p0_data, 3);
2779   1          if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P5(P34)
2780   1              BIT_SET_ZERO(p3_data, 4);
2781   1          if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P6(P35)
2782   1              BIT_SET_ZERO(p3_data, 5);
2783   1          if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P7(P36)
2784   1              BIT_SET_ZERO(p3_data, 6);
2785   1          if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P8(P37)
2786   1              BIT_SET_ZERO(p3_data, 7);
2787   1      
2788   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SEVENTH_BIT)) )// check P0(P33)
2789   1              BIT_SET_ZERO(p3_data, 3);
2790   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SIXTH_BIT)) )// check P10(P21)
2791   1              BIT_SET_ZERO(p2_data, 1);
2792   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FIFTH_BIT)) )// check P11(P22)
2793   1              BIT_SET_ZERO(p2_data, 2);
2794   1          if ( (FIND_BIT(strData[bytePos][pos + 1], THIRD_BIT)) )// check P12(P23)
2795   1              BIT_SET_ZERO(p2_data, 3);
2796   1          GPIO_setOpenDrainOutput(3, 7);//  P8
2797   1          GPIO_setPushPullupOutput(2, 0);// P9
2798   1          P0 = p0_data;
2799   1          P2 = p2_data;
2800   1          P3 = p3_data;
2801   1          P20 = 1;
2802   1      
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 54  

2803   1          /***************************** P10 *************************************** */
2804   1          pos += 2;
2805   1          p0_data = USE_P0;
2806   1          p1_data = USE_P1;
2807   1          p2_data = USE_P2;
2808   1          p3_data = USE_P3;
2809   1          if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P1(P00) value
2810   1              BIT_SET_ZERO(p0_data, 0);
2811   1          if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P2(P01)
2812   1              BIT_SET_ZERO(p0_data, 1);
2813   1          if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P3(P02)
2814   1              BIT_SET_ZERO(p0_data, 2);
2815   1          if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P4(P03)
2816   1              BIT_SET_ZERO(p0_data, 3);
2817   1          if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P5(P34)
2818   1              BIT_SET_ZERO(p3_data, 4);
2819   1          if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P6(P35)
2820   1              BIT_SET_ZERO(p3_data, 5);
2821   1          if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P7(P36)
2822   1              BIT_SET_ZERO(p3_data, 6);
2823   1          if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P8(P37)
2824   1              BIT_SET_ZERO(p3_data, 7);
2825   1      
2826   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SEVENTH_BIT)) )// check P9(P20)
2827   1              BIT_SET_ZERO(p2_data, 0);
2828   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SIXTH_BIT)) )// check P0(P33)
2829   1              BIT_SET_ZERO(p3_data, 3);
2830   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FIFTH_BIT)) )// check P11(P22)
2831   1              BIT_SET_ZERO(p2_data, 2);
2832   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FOURTH_BIT)) )// check P12(P23)
2833   1              BIT_SET_ZERO(p2_data, 3);
2834   1          GPIO_setOpenDrainOutput(2, 0);//  P9
2835   1          GPIO_setPushPullupOutput(2, 1);//P10
2836   1          P0 = p0_data;
2837   1          P2 = p2_data;
2838   1          P3 = p3_data;
2839   1          P21 = 1;
2840   1      
2841   1          /***************************** P11 *************************************** */
2842   1          pos += 2;
2843   1          p0_data = USE_P0;
2844   1          p1_data = USE_P1;
2845   1          p2_data = USE_P2;
2846   1          p3_data = USE_P3;
2847   1          if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P1(P00) value
2848   1              BIT_SET_ZERO(p0_data, 0);
2849   1          if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P2(P01)
2850   1              BIT_SET_ZERO(p0_data, 1);
2851   1          if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P3(P02)
2852   1              BIT_SET_ZERO(p0_data, 2);
2853   1          if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P4(P03)
2854   1              BIT_SET_ZERO(p0_data, 3);
2855   1          if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P5(P34)
2856   1              BIT_SET_ZERO(p3_data, 4);
2857   1          if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P6(P35)
2858   1              BIT_SET_ZERO(p3_data, 5);
2859   1          if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P7(P36)
2860   1              BIT_SET_ZERO(p3_data, 6);
2861   1          if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P8(P37)
2862   1              BIT_SET_ZERO(p3_data, 7);
2863   1      
2864   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SEVENTH_BIT)) )// check P9(P20)
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 55  

2865   1              BIT_SET_ZERO(p2_data, 0);
2866   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SIXTH_BIT)) )// check P10(P21)
2867   1              BIT_SET_ZERO(p2_data, 1);
2868   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FIFTH_BIT)) )// check P0(P33)
2869   1              BIT_SET_ZERO(p3_data, 3);
2870   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FOURTH_BIT)) )// check P12(P23)
2871   1              BIT_SET_ZERO(p2_data, 3);
2872   1          GPIO_setOpenDrainOutput(2, 1);// P10
2873   1          GPIO_setPushPullupOutput(2, 2);//P11
2874   1          P0 = p0_data;
2875   1          P2 = p2_data;
2876   1          P3 = p3_data;
2877   1          P22 = 1;
2878   1      
2879   1          /***************************** P12 *************************************** */
2880   1          pos += 2;
2881   1          p0_data = USE_P0;
2882   1          p1_data = USE_P1;
2883   1          p2_data = USE_P2;
2884   1          p3_data = USE_P3;
2885   1          if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P1(P00) value
2886   1              BIT_SET_ZERO(p0_data, 0);
2887   1          if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P2(P01)
2888   1              BIT_SET_ZERO(p0_data, 1);
2889   1          if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P3(P02)
2890   1              BIT_SET_ZERO(p0_data, 2);
2891   1          if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P4(P03)
2892   1              BIT_SET_ZERO(p0_data, 3);
2893   1          if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P5(P34)
2894   1              BIT_SET_ZERO(p3_data, 4);
2895   1          if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P6(P35)
2896   1              BIT_SET_ZERO(p3_data, 5);
2897   1          if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P7(P36)
2898   1              BIT_SET_ZERO(p3_data, 6);
2899   1          if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P8(P37)
2900   1              BIT_SET_ZERO(p3_data, 7);
2901   1      
2902   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SEVENTH_BIT)) )// check P9(P20)
2903   1              BIT_SET_ZERO(p2_data, 0);
2904   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SIXTH_BIT)) )// check P10(P21)
2905   1              BIT_SET_ZERO(p2_data, 1);
2906   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FIFTH_BIT)) )// check P11(P22)
2907   1              BIT_SET_ZERO(p2_data, 3);
2908   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FOURTH_BIT)) )// check P0(P33)
2909   1              BIT_SET_ZERO(p3_data, 3);
2910   1          GPIO_setOpenDrainOutput(2, 2);// P11
2911   1          GPIO_setPushPullupOutput(2, 3);//P12
2912   1          P0 = p0_data;
2913   1          P2 = p2_data;
2914   1          P3 = p3_data;
2915   1          P23 = 1;
2916   1      #endif
2917   1      
2918   1          GPIO_setOpenDrainOutput(2, 3);
2919   1          P23 = 0;
2920   1          return;
2921   1      }
2922          
2923          /// @brief LEDÁÇπÈòµ1ÊòæÁ§∫
2924          /// @param strData ÊñáÂ≠óÊòæÁ§∫Á†Å([2][12])
2925          /// @param bytes ËØ•ÊñáÂ≠óÊâÄÂç†Â≠óËäÇ‰Ωç
2926          /// @param arrLen ÊòæÁ§∫Á†ÅÈïøÂ∫¶
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 56  

2927          void LED_screen1_test(const unsigned char(*strData)[12],
2928                                const unsigned char bytes,
2929                                const unsigned char arrLen)
2930          {
2931   1          unsigned char p0_data = USE_P0,
2932   1              p1_data = USE_P1,
2933   1              p2_data = USE_P2,
2934   1              p3_data = USE_P3,
2935   1              pos = 0x00,
2936   1              bytePos = 0x00;
2937   1          P0 = p0_data;
2938   1          P1 = p1_data;                   // enable P1.0~P1.7
2939   1          P2 = p2_data;                   // enable P2.4~P2.7
2940   1          P3 = p3_data;
2941   1          if ( arrLen < MIN_ARR_LEN || strData == NULL )// ËæìÂÖ•ÊòæÁ§∫Á†ÅÈïøÂ∫¶‰∏çË∂≥ÊàñÊåáÈíà‰∏∫Á©∫
2942   1              return;
2943   1      
2944   1      /***************************** P1 *************************************** */
2945   1          if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P13(P10)
2946   1              BIT_SET_ZERO(p1_data, 0);
2947   1          if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P14(P11)
2948   1              BIT_SET_ZERO(p1_data, 1);
2949   1          if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P15(P12)
2950   1              BIT_SET_ZERO(p1_data, 2);
2951   1          if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P16(P13)
2952   1              BIT_SET_ZERO(p1_data, 3);
2953   1          if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P17(P14)
2954   1              BIT_SET_ZERO(p1_data, 4);
2955   1          if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P18(P15)
2956   1              BIT_SET_ZERO(p1_data, 5);
2957   1          if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P19(P16)
2958   1              BIT_SET_ZERO(p1_data, 6);
2959   1          if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P20(P17)
2960   1              BIT_SET_ZERO(p1_data, 7);
2961   1      
2962   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SEVENTH_BIT)) )// check P21(P24)
2963   1              BIT_SET_ZERO(p2_data, 4);
2964   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SIXTH_BIT)) )// check P22(P25)
2965   1              BIT_SET_ZERO(p2_data, 5);
2966   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FIFTH_BIT)) )// check P23(P26)
2967   1              BIT_SET_ZERO(p2_data, 6);
2968   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FOURTH_BIT)) )// check P24(P27)
2969   1              BIT_SET_ZERO(p2_data, 7);
2970   1          GPIO_setOpenDrainOutput(3, 3);//  P0
2971   1          GPIO_setPushPullupOutput(0, 0);// P1
2972   1          P1 = p1_data;
2973   1          P2 = p2_data;
2974   1          P00 = 1;
2975   1      
2976   1      /***************************** P2 *************************************** */
2977   1          pos += 2;
2978   1          p0_data = USE_P0;
2979   1          p1_data = USE_P1;
2980   1          p2_data = USE_P2;
2981   1          p3_data = USE_P3;
2982   1          if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P13(P10)
2983   1              BIT_SET_ZERO(p1_data, 0);
2984   1          if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P14(P11)
2985   1              BIT_SET_ZERO(p1_data, 1);
2986   1          if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P15(P12)
2987   1              BIT_SET_ZERO(p1_data, 2);
2988   1          if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P16(P13)
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 57  

2989   1              BIT_SET_ZERO(p1_data, 3);
2990   1          if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P17(P14)
2991   1              BIT_SET_ZERO(p1_data, 4);
2992   1          if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P18(P15)
2993   1              BIT_SET_ZERO(p1_data, 5);
2994   1          if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P19(P16)
2995   1              BIT_SET_ZERO(p1_data, 6);
2996   1          if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P20(P17)
2997   1              BIT_SET_ZERO(p1_data, 7);
2998   1      
2999   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SEVENTH_BIT)) )// check P21(P24)
3000   1              BIT_SET_ZERO(p2_data, 4);
3001   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SIXTH_BIT)) )// check P22(P25)
3002   1              BIT_SET_ZERO(p2_data, 5);
3003   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FIFTH_BIT)) )// check P23(P26)
3004   1              BIT_SET_ZERO(p2_data, 6);
3005   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FOURTH_BIT)) )// check P24(P27)
3006   1              BIT_SET_ZERO(p2_data, 7);
3007   1          GPIO_setOpenDrainOutput(0, 0);//  P1
3008   1          GPIO_setPushPullupOutput(0, 1);// P2
3009   1          P1 = p1_data;
3010   1          P2 = p2_data;
3011   1          P01 = 1;
3012   1      
3013   1      /***************************** P3 *************************************** */
3014   1          pos += 2;
3015   1          p0_data = USE_P0;
3016   1          p1_data = USE_P1;
3017   1          p2_data = USE_P2;
3018   1          p3_data = USE_P3;
3019   1          if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P13(P10)
3020   1              BIT_SET_ZERO(p1_data, 0);
3021   1          if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P14(P11)
3022   1              BIT_SET_ZERO(p1_data, 1);
3023   1          if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P15(P12)
3024   1              BIT_SET_ZERO(p1_data, 2);
3025   1          if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P16(P13)
3026   1              BIT_SET_ZERO(p1_data, 3);
3027   1          if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P17(P14)
3028   1              BIT_SET_ZERO(p1_data, 4);
3029   1          if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P18(P15)
3030   1              BIT_SET_ZERO(p1_data, 5);
3031   1          if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P19(P16)
3032   1              BIT_SET_ZERO(p1_data, 6);
3033   1          if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P20(P17)
3034   1              BIT_SET_ZERO(p1_data, 7);
3035   1      
3036   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SEVENTH_BIT)) )// check P21(P24)
3037   1              BIT_SET_ZERO(p2_data, 4);
3038   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SIXTH_BIT)) )// check P22(P25)
3039   1              BIT_SET_ZERO(p2_data, 5);
3040   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FIFTH_BIT)) )// check P23(P26)
3041   1              BIT_SET_ZERO(p2_data, 6);
3042   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FOURTH_BIT)) )// check P24(P27)
3043   1              BIT_SET_ZERO(p2_data, 7);
3044   1          GPIO_setOpenDrainOutput(0, 1);//  P2
3045   1          GPIO_setPushPullupOutput(0, 2);// P3
3046   1          P1 = p1_data;
3047   1          P2 = p2_data;
3048   1          P02 = 1;
3049   1      
3050   1      /***************************** P4 *************************************** */
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 58  

3051   1          pos += 2;
3052   1          p0_data = USE_P0;
3053   1          p1_data = USE_P1;
3054   1          p2_data = USE_P2;
3055   1          p3_data = USE_P3;
3056   1          if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P13(P10)
3057   1              BIT_SET_ZERO(p1_data, 0);
3058   1          if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P14(P11)
3059   1              BIT_SET_ZERO(p1_data, 1);
3060   1          if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P15(P12)
3061   1              BIT_SET_ZERO(p1_data, 2);
3062   1          if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P16(P13)
3063   1              BIT_SET_ZERO(p1_data, 3);
3064   1          if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P17(P14)
3065   1              BIT_SET_ZERO(p1_data, 4);
3066   1          if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P18(P15)
3067   1              BIT_SET_ZERO(p1_data, 5);
3068   1          if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P19(P16)
3069   1              BIT_SET_ZERO(p1_data, 6);
3070   1          if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P20(P17)
3071   1              BIT_SET_ZERO(p1_data, 7);
3072   1      
3073   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SEVENTH_BIT)) )// check P21(P24)
3074   1              BIT_SET_ZERO(p2_data, 4);
3075   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SIXTH_BIT)) )// check P22(P25)
3076   1              BIT_SET_ZERO(p2_data, 5);
3077   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FIFTH_BIT)) )// check P23(P26)
3078   1              BIT_SET_ZERO(p2_data, 6);
3079   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FOURTH_BIT)) )// check P24(P27)
3080   1              BIT_SET_ZERO(p2_data, 7);
3081   1          GPIO_setOpenDrainOutput(0, 2);//  P3
3082   1          GPIO_setPushPullupOutput(0, 3);// P4
3083   1          P1 = p1_data;
3084   1          P2 = p2_data;
3085   1          P03 = 1;
3086   1      
3087   1      /***************************** P5 *************************************** */
3088   1          pos += 2;
3089   1          p0_data = USE_P0;
3090   1          p1_data = USE_P1;
3091   1          p2_data = USE_P2;
3092   1          p3_data = USE_P3;
3093   1          if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P13(P10)
3094   1              BIT_SET_ZERO(p1_data, 0);
3095   1          if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P14(P11)
3096   1              BIT_SET_ZERO(p1_data, 1);
3097   1          if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P15(P12)
3098   1              BIT_SET_ZERO(p1_data, 2);
3099   1          if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P16(P13)
3100   1              BIT_SET_ZERO(p1_data, 3);
3101   1          if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P17(P14)
3102   1              BIT_SET_ZERO(p1_data, 4);
3103   1          if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P18(P15)
3104   1              BIT_SET_ZERO(p1_data, 5);
3105   1          if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P19(P16)
3106   1              BIT_SET_ZERO(p1_data, 6);
3107   1          if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P20(P17)
3108   1              BIT_SET_ZERO(p1_data, 7);
3109   1      
3110   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SEVENTH_BIT)) )// check P21(P24)
3111   1              BIT_SET_ZERO(p2_data, 4);
3112   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SIXTH_BIT)) )// check P22(P25)
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 59  

3113   1              BIT_SET_ZERO(p2_data, 5);
3114   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FIFTH_BIT)) )// check P23(P26)
3115   1              BIT_SET_ZERO(p2_data, 6);
3116   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FOURTH_BIT)) )// check P24(P27)
3117   1              BIT_SET_ZERO(p2_data, 7);
3118   1          GPIO_setOpenDrainOutput(0, 3);//  P4
3119   1          GPIO_setPushPullupOutput(3, 4);// P5
3120   1          P1 = p1_data;
3121   1          P2 = p2_data;
3122   1          P34 = 1;
3123   1      
3124   1      /***************************** P6 *************************************** */
3125   1          pos += 2;
3126   1          p0_data = USE_P0;
3127   1          p1_data = USE_P1;
3128   1          p2_data = USE_P2;
3129   1          p3_data = USE_P3;
3130   1          if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P13(P10)
3131   1              BIT_SET_ZERO(p1_data, 0);
3132   1          if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P14(P11)
3133   1              BIT_SET_ZERO(p1_data, 1);
3134   1          if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P15(P12)
3135   1              BIT_SET_ZERO(p1_data, 2);
3136   1          if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P16(P13)
3137   1              BIT_SET_ZERO(p1_data, 3);
3138   1          if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P17(P14)
3139   1              BIT_SET_ZERO(p1_data, 4);
3140   1          if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P18(P15)
3141   1              BIT_SET_ZERO(p1_data, 5);
3142   1          if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P19(P16)
3143   1              BIT_SET_ZERO(p1_data, 6);
3144   1          if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P20(P17)
3145   1              BIT_SET_ZERO(p1_data, 7);
3146   1      
3147   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SEVENTH_BIT)) )// check P21(P24)
3148   1              BIT_SET_ZERO(p2_data, 4);
3149   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SIXTH_BIT)) )// check P22(P25)
3150   1              BIT_SET_ZERO(p2_data, 5);
3151   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FIFTH_BIT)) )// check P23(P26)
3152   1              BIT_SET_ZERO(p2_data, 6);
3153   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FOURTH_BIT)) )// check P24(P27)
3154   1              BIT_SET_ZERO(p2_data, 7);
3155   1          GPIO_setOpenDrainOutput(3, 4);//  P5
3156   1          GPIO_setPushPullupOutput(3, 5);// P6
3157   1          P1 = p1_data;
3158   1          P2 = p2_data;
3159   1          P35 = 1;
3160   1      
3161   1      /***************************** P7 *************************************** */
3162   1          pos += 2;
3163   1          if ( bytes < MIN_BYTES )// Â≠óÁ¨¶Â≠óËäÇÊï∞‰∏çË∂≥, ÁªìÊùüËØ•Â≠óÊòæÁ§∫
3164   1              return;
3165   1          if ( pos >= arrLen )
3166   1          {
3167   2              bytePos++;
3168   2              pos = 0;
3169   2          }
3170   1          p0_data = USE_P0;
3171   1          p1_data = USE_P1;
3172   1          p2_data = USE_P2;
3173   1          p3_data = USE_P3;
3174   1          if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P13(P10)
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 60  

3175   1              BIT_SET_ZERO(p1_data, 0);
3176   1          if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P14(P11)
3177   1              BIT_SET_ZERO(p1_data, 1);
3178   1          if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P15(P12)
3179   1              BIT_SET_ZERO(p1_data, 2);
3180   1          if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P16(P13)
3181   1              BIT_SET_ZERO(p1_data, 3);
3182   1          if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P17(P14)
3183   1              BIT_SET_ZERO(p1_data, 4);
3184   1          if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P18(P15)
3185   1              BIT_SET_ZERO(p1_data, 5);
3186   1          if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P19(P16)
3187   1              BIT_SET_ZERO(p1_data, 6);
3188   1          if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P20(P17)
3189   1              BIT_SET_ZERO(p1_data, 7);
3190   1      
3191   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SEVENTH_BIT)) )// check P21(P24)
3192   1              BIT_SET_ZERO(p2_data, 4);
3193   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SIXTH_BIT)) )// check P22(P25)
3194   1              BIT_SET_ZERO(p2_data, 5);
3195   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FIFTH_BIT)) )// check P23(P26)
3196   1              BIT_SET_ZERO(p2_data, 6);
3197   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FOURTH_BIT)) )// check P24(P27)
3198   1              BIT_SET_ZERO(p2_data, 7);
3199   1          GPIO_setOpenDrainOutput(3, 5);//  P6
3200   1          GPIO_setPushPullupOutput(3, 6);// P7
3201   1          P1 = p1_data;
3202   1          P2 = p2_data;
3203   1          P36 = 1;
3204   1      
3205   1      /***************************** P8 *************************************** */
3206   1          pos += 2;
3207   1          p0_data = USE_P0;
3208   1          p1_data = USE_P1;
3209   1          p2_data = USE_P2;
3210   1          p3_data = USE_P3;
3211   1          if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P13(P10)
3212   1              BIT_SET_ZERO(p1_data, 0);
3213   1          if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P14(P11)
3214   1              BIT_SET_ZERO(p1_data, 1);
3215   1          if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P15(P12)
3216   1              BIT_SET_ZERO(p1_data, 2);
3217   1          if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P16(P13)
3218   1              BIT_SET_ZERO(p1_data, 3);
3219   1          if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P17(P14)
3220   1              BIT_SET_ZERO(p1_data, 4);
3221   1          if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P18(P15)
3222   1              BIT_SET_ZERO(p1_data, 5);
3223   1          if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P19(P16)
3224   1              BIT_SET_ZERO(p1_data, 6);
3225   1          if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P20(P17)
3226   1              BIT_SET_ZERO(p1_data, 7);
3227   1      
3228   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SEVENTH_BIT)) )// check P21(P24)
3229   1              BIT_SET_ZERO(p2_data, 4);
3230   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SIXTH_BIT)) )// check P22(P25)
3231   1              BIT_SET_ZERO(p2_data, 5);
3232   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FIFTH_BIT)) )// check P23(P26)
3233   1              BIT_SET_ZERO(p2_data, 6);
3234   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FOURTH_BIT)) )// check P24(P27)
3235   1              BIT_SET_ZERO(p2_data, 7);
3236   1          GPIO_setOpenDrainOutput(3, 6);//  P7
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 61  

3237   1          GPIO_setPushPullupOutput(3, 7);// P8
3238   1          P1 = p1_data;
3239   1          P2 = p2_data;
3240   1          P37 = 1;
3241   1      
3242   1      /***************************** P9 *************************************** */
3243   1          pos += 2;
3244   1          p0_data = USE_P0;
3245   1          p1_data = USE_P1;
3246   1          p2_data = USE_P2;
3247   1          p3_data = USE_P3;
3248   1          if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P13(P10)
3249   1              BIT_SET_ZERO(p1_data, 0);
3250   1          if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P14(P11)
3251   1              BIT_SET_ZERO(p1_data, 1);
3252   1          if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P15(P12)
3253   1              BIT_SET_ZERO(p1_data, 2);
3254   1          if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P16(P13)
3255   1              BIT_SET_ZERO(p1_data, 3);
3256   1          if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P17(P14)
3257   1              BIT_SET_ZERO(p1_data, 4);
3258   1          if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P18(P15)
3259   1              BIT_SET_ZERO(p1_data, 5);
3260   1          if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P19(P16)
3261   1              BIT_SET_ZERO(p1_data, 6);
3262   1          if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P20(P17)
3263   1              BIT_SET_ZERO(p1_data, 7);
3264   1      
3265   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SEVENTH_BIT)) )// check P21(P24)
3266   1              BIT_SET_ZERO(p2_data, 4);
3267   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SIXTH_BIT)) )// check P22(P25)
3268   1              BIT_SET_ZERO(p2_data, 5);
3269   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FIFTH_BIT)) )// check P23(P26)
3270   1              BIT_SET_ZERO(p2_data, 6);
3271   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FOURTH_BIT)) )// check P24(P27)
3272   1              BIT_SET_ZERO(p2_data, 7);
3273   1          GPIO_setOpenDrainOutput(3, 7);//  P8
3274   1          GPIO_setPushPullupOutput(2, 0);// P9
3275   1          P1 = p1_data;
3276   1          P2 = p2_data;
3277   1          P20 = 1;
3278   1      
3279   1      /***************************** P10 *************************************** */
3280   1          pos += 2;
3281   1          p0_data = USE_P0;
3282   1          p1_data = USE_P1;
3283   1          p2_data = USE_P2;
3284   1          p3_data = USE_P3;
3285   1          if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P13(P10)
3286   1              BIT_SET_ZERO(p1_data, 0);
3287   1          if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P14(P11)
3288   1              BIT_SET_ZERO(p1_data, 1);
3289   1          if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P15(P12)
3290   1              BIT_SET_ZERO(p1_data, 2);
3291   1          if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P16(P13)
3292   1              BIT_SET_ZERO(p1_data, 3);
3293   1          if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P17(P14)
3294   1              BIT_SET_ZERO(p1_data, 4);
3295   1          if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P18(P15)
3296   1              BIT_SET_ZERO(p1_data, 5);
3297   1          if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P19(P16)
3298   1              BIT_SET_ZERO(p1_data, 6);
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 62  

3299   1          if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P20(P17)
3300   1              BIT_SET_ZERO(p1_data, 7);
3301   1      
3302   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SEVENTH_BIT)) )// check P21(P24)
3303   1              BIT_SET_ZERO(p2_data, 4);
3304   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SIXTH_BIT)) )// check P22(P25)
3305   1              BIT_SET_ZERO(p2_data, 5);
3306   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FIFTH_BIT)) )// check P23(P26)
3307   1              BIT_SET_ZERO(p2_data, 6);
3308   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FOURTH_BIT)) )// check P24(P27)
3309   1              BIT_SET_ZERO(p2_data, 7);
3310   1          GPIO_setOpenDrainOutput(2, 0);//  P9
3311   1          GPIO_setPushPullupOutput(2, 1);//P10
3312   1          P1 = p1_data;
3313   1          P2 = p2_data;
3314   1          P21 = 1;
3315   1      
3316   1      /***************************** P11 *************************************** */
3317   1          pos += 2;
3318   1          p0_data = USE_P0;
3319   1          p1_data = USE_P1;
3320   1          p2_data = USE_P2;
3321   1          p3_data = USE_P3;
3322   1          if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P13(P10)
3323   1              BIT_SET_ZERO(p1_data, 0);
3324   1          if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P14(P11)
3325   1              BIT_SET_ZERO(p1_data, 1);
3326   1          if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P15(P12)
3327   1              BIT_SET_ZERO(p1_data, 2);
3328   1          if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P16(P13)
3329   1              BIT_SET_ZERO(p1_data, 3);
3330   1          if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P17(P14)
3331   1              BIT_SET_ZERO(p1_data, 4);
3332   1          if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P18(P15)
3333   1              BIT_SET_ZERO(p1_data, 5);
3334   1          if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P19(P16)
3335   1              BIT_SET_ZERO(p1_data, 6);
3336   1          if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P20(P17)
3337   1              BIT_SET_ZERO(p1_data, 7);
3338   1      
3339   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SEVENTH_BIT)) )// check P21(P24)
3340   1              BIT_SET_ZERO(p2_data, 4);
3341   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SIXTH_BIT)) )// check P22(P25)
3342   1              BIT_SET_ZERO(p2_data, 5);
3343   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FIFTH_BIT)) )// check P23(P26)
3344   1              BIT_SET_ZERO(p2_data, 6);
3345   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FOURTH_BIT)) )// check P24(P27)
3346   1              BIT_SET_ZERO(p2_data, 7);
3347   1          GPIO_setOpenDrainOutput(2, 1);// P10
3348   1          GPIO_setPushPullupOutput(2, 2);//P11
3349   1          P1 = p1_data;
3350   1          P2 = p2_data;
3351   1          P22 = 1;
3352   1      
3353   1      /***************************** P12 *************************************** */
3354   1          pos += 2;
3355   1          p0_data = USE_P0;
3356   1          p1_data = USE_P1;
3357   1          p2_data = USE_P2;
3358   1          p3_data = USE_P3;
3359   1          if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P13(P10)
3360   1              BIT_SET_ZERO(p1_data, 0);
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 63  

3361   1          if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P14(P11)
3362   1              BIT_SET_ZERO(p1_data, 1);
3363   1          if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P15(P12)
3364   1              BIT_SET_ZERO(p1_data, 2);
3365   1          if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P16(P13)
3366   1              BIT_SET_ZERO(p1_data, 3);
3367   1          if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P17(P14)
3368   1              BIT_SET_ZERO(p1_data, 4);
3369   1          if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P18(P15)
3370   1              BIT_SET_ZERO(p1_data, 5);
3371   1          if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P19(P16)
3372   1              BIT_SET_ZERO(p1_data, 6);
3373   1          if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P20(P17)
3374   1              BIT_SET_ZERO(p1_data, 7);
3375   1      
3376   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SEVENTH_BIT)) )// check P21(P24)
3377   1              BIT_SET_ZERO(p2_data, 4);
3378   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SIXTH_BIT)) )// check P22(P25)
3379   1              BIT_SET_ZERO(p2_data, 5);
3380   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FIFTH_BIT)) )// check P23(P26)
3381   1              BIT_SET_ZERO(p2_data, 6);
3382   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FOURTH_BIT)) )// check P24(P27)
3383   1              BIT_SET_ZERO(p2_data, 7);
3384   1          GPIO_setOpenDrainOutput(2, 2);// P11
3385   1          GPIO_setPushPullupOutput(2, 3);//P12
3386   1          P1 = p1_data;
3387   1          P2 = p2_data;
3388   1          P23 = 1;
3389   1      
3390   1          GPIO_setOpenDrainOutput(2, 3);
3391   1          P23 = 0;
3392   1          return;
3393   1      }
3394          
3395          /// @brief LEDÁÇπÈòµ2ÊòæÁ§∫
3396          /// @param strData ÊñáÂ≠óÊòæÁ§∫Á†Å([2][12])
3397          /// @param bytes ËØ•ÊñáÂ≠óÊâÄÂç†Â≠óËäÇ‰Ωç
3398          /// @param arrLen ÊòæÁ§∫Á†ÅÈïøÂ∫¶
3399          void LED_screen2_test(const unsigned char(*strData)[12],
3400                                const unsigned char bytes,
3401                                const unsigned char arrLen)
3402          {
3403   1          unsigned char p0_data = USE_P0,
3404   1              p1_data = USE_P1,
3405   1              p2_data = USE_P2,
3406   1              p3_data = USE_P3,
3407   1              pos = 0x00,
3408   1              bytePos = 0x00;
3409   1          P0 = p0_data;
3410   1          P1 = p1_data;                   // disable P1.0~P1.7
3411   1          P2 = p2_data;                   // disable P2.4~P2.7
3412   1          P3 = p3_data;
3413   1          if ( arrLen < MIN_ARR_LEN || strData == NULL )// ËæìÂÖ•ÊòæÁ§∫Á†ÅÈïøÂ∫¶‰∏çË∂≥ÊàñÊåáÈíà‰∏∫Á©∫
3414   1              return;
3415   1      
3416   1      /***************************** P13 *************************************** */
3417   1          if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P1(P00)
3418   1              BIT_SET_ZERO(p0_data, 0);
3419   1          if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P2(P01) value
3420   1              BIT_SET_ZERO(p0_data, 1);
3421   1          if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P3(P02)
3422   1              BIT_SET_ZERO(p0_data, 2);
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 64  

3423   1          if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P4(P03)
3424   1              BIT_SET_ZERO(p0_data, 3);
3425   1          if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P5(P34)
3426   1              BIT_SET_ZERO(p3_data, 4);
3427   1          if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P6(P35)
3428   1              BIT_SET_ZERO(p3_data, 5);
3429   1          if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P7(P36)
3430   1              BIT_SET_ZERO(p3_data, 6);
3431   1          if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P8(P37)
3432   1              BIT_SET_ZERO(p3_data, 7);
3433   1      
3434   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SEVENTH_BIT)) )// check P9(P20)
3435   1              BIT_SET_ZERO(p2_data, 0);
3436   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SIXTH_BIT)) )// check P10(P21)
3437   1              BIT_SET_ZERO(p2_data, 1);
3438   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FIFTH_BIT)) )// check P11(P22)
3439   1              BIT_SET_ZERO(p2_data, 2);
3440   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FOURTH_BIT)) )// check P12(P23)
3441   1              BIT_SET_ZERO(p2_data, 3);
3442   1          GPIO_setOpenDrainOutput(2, 3);// P12
3443   1          GPIO_setPushPullupOutput(1, 0);//P13
3444   1          P0 = p0_data;
3445   1          P2 = p2_data;
3446   1          P3 = p3_data;
3447   1          P10 = 1;
3448   1      
3449   1      /***************************** P14 *************************************** */
3450   1          pos += 2;
3451   1          p0_data = USE_P0;
3452   1          p1_data = USE_P1;
3453   1          p2_data = USE_P2;
3454   1          p3_data = USE_P3;
3455   1          if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P1(P00)
3456   1              BIT_SET_ZERO(p0_data, 0);
3457   1          if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P2(P01) value
3458   1              BIT_SET_ZERO(p0_data, 1);
3459   1          if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P3(P02)
3460   1              BIT_SET_ZERO(p0_data, 2);
3461   1          if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P4(P03)
3462   1              BIT_SET_ZERO(p0_data, 3);
3463   1          if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P5(P34)
3464   1              BIT_SET_ZERO(p3_data, 4);
3465   1          if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P6(P35)
3466   1              BIT_SET_ZERO(p3_data, 5);
3467   1          if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P7(P36)
3468   1              BIT_SET_ZERO(p3_data, 6);
3469   1          if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P8(P37)
3470   1              BIT_SET_ZERO(p3_data, 7);
3471   1      
3472   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SEVENTH_BIT)) )// check P9(P20)
3473   1              BIT_SET_ZERO(p2_data, 0);
3474   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SIXTH_BIT)) )// check P10(P21)
3475   1              BIT_SET_ZERO(p2_data, 1);
3476   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FIFTH_BIT)) )// check P11(P22)
3477   1              BIT_SET_ZERO(p2_data, 2);
3478   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FOURTH_BIT)) )// check P12(P23)
3479   1              BIT_SET_ZERO(p2_data, 3);
3480   1          GPIO_setOpenDrainOutput(1, 0);// P13
3481   1          GPIO_setPushPullupOutput(1, 1);//P14
3482   1          P0 = p0_data;
3483   1          P2 = p2_data;
3484   1          P3 = p3_data;
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 65  

3485   1          P11 = 1;
3486   1      
3487   1      /***************************** P15 *************************************** */
3488   1          pos += 2;
3489   1          p0_data = USE_P0;
3490   1          p1_data = USE_P1;
3491   1          p2_data = USE_P2;
3492   1          p3_data = USE_P3;
3493   1          if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P1(P00)
3494   1              BIT_SET_ZERO(p0_data, 0);
3495   1          if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P2(P01) value
3496   1              BIT_SET_ZERO(p0_data, 1);
3497   1          if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P3(P02)
3498   1              BIT_SET_ZERO(p0_data, 2);
3499   1          if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P4(P03)
3500   1              BIT_SET_ZERO(p0_data, 3);
3501   1          if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P5(P34)
3502   1              BIT_SET_ZERO(p3_data, 4);
3503   1          if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P6(P35)
3504   1              BIT_SET_ZERO(p3_data, 5);
3505   1          if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P7(P36)
3506   1              BIT_SET_ZERO(p3_data, 6);
3507   1          if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P8(P37)
3508   1              BIT_SET_ZERO(p3_data, 7);
3509   1      
3510   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SEVENTH_BIT)) )// check P9(P20)
3511   1              BIT_SET_ZERO(p2_data, 0);
3512   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SIXTH_BIT)) )// check P10(P21)
3513   1              BIT_SET_ZERO(p2_data, 1);
3514   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FIFTH_BIT)) )// check P11(P22)
3515   1              BIT_SET_ZERO(p2_data, 2);
3516   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FOURTH_BIT)) )// check P12(P23)
3517   1              BIT_SET_ZERO(p2_data, 3);
3518   1          GPIO_setOpenDrainOutput(1, 1);// P14
3519   1          GPIO_setPushPullupOutput(1, 2);//P15
3520   1          P0 = p0_data;
3521   1          P2 = p2_data;
3522   1          P3 = p3_data;
3523   1          P12 = 1;
3524   1      
3525   1      /***************************** P16 *************************************** */
3526   1          pos += 2;
3527   1          p0_data = USE_P0;
3528   1          p1_data = USE_P1;
3529   1          p2_data = USE_P2;
3530   1          p3_data = USE_P3;
3531   1          if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P1(P00)
3532   1              BIT_SET_ZERO(p0_data, 0);
3533   1          if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P2(P01) value
3534   1              BIT_SET_ZERO(p0_data, 1);
3535   1          if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P3(P02)
3536   1              BIT_SET_ZERO(p0_data, 2);
3537   1          if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P4(P03)
3538   1              BIT_SET_ZERO(p0_data, 3);
3539   1          if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P5(P34)
3540   1              BIT_SET_ZERO(p3_data, 4);
3541   1          if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P6(P35)
3542   1              BIT_SET_ZERO(p3_data, 5);
3543   1          if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P7(P36)
3544   1              BIT_SET_ZERO(p3_data, 6);
3545   1          if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P8(P37)
3546   1              BIT_SET_ZERO(p3_data, 7);
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 66  

3547   1      
3548   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SEVENTH_BIT)) )// check P9(P20)
3549   1              BIT_SET_ZERO(p2_data, 0);
3550   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SIXTH_BIT)) )// check P10(P21)
3551   1              BIT_SET_ZERO(p2_data, 1);
3552   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FIFTH_BIT)) )// check P11(P22)
3553   1              BIT_SET_ZERO(p2_data, 2);
3554   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FOURTH_BIT)) )// check P12(P23)
3555   1              BIT_SET_ZERO(p2_data, 3);
3556   1          GPIO_setOpenDrainOutput(1, 2);// P15
3557   1          GPIO_setPushPullupOutput(1, 3);//P16
3558   1          P0 = p0_data;
3559   1          P2 = p2_data;
3560   1          P3 = p3_data;
3561   1          P13 = 1;
3562   1      
3563   1      /***************************** P17 *************************************** */
3564   1          pos += 2;
3565   1          p0_data = USE_P0;
3566   1          p1_data = USE_P1;
3567   1          p2_data = USE_P2;
3568   1          p3_data = USE_P3;
3569   1          if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P1(P00)
3570   1              BIT_SET_ZERO(p0_data, 0);
3571   1          if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P2(P01) value
3572   1              BIT_SET_ZERO(p0_data, 1);
3573   1          if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P3(P02)
3574   1              BIT_SET_ZERO(p0_data, 2);
3575   1          if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P4(P03)
3576   1              BIT_SET_ZERO(p0_data, 3);
3577   1          if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P5(P34)
3578   1              BIT_SET_ZERO(p3_data, 4);
3579   1          if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P6(P35)
3580   1              BIT_SET_ZERO(p3_data, 5);
3581   1          if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P7(P36)
3582   1              BIT_SET_ZERO(p3_data, 6);
3583   1          if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P8(P37)
3584   1              BIT_SET_ZERO(p3_data, 7);
3585   1      
3586   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SEVENTH_BIT)) )// check P9(P20)
3587   1              BIT_SET_ZERO(p2_data, 0);
3588   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SIXTH_BIT)) )// check P10(P21)
3589   1              BIT_SET_ZERO(p2_data, 1);
3590   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FIFTH_BIT)) )// check P11(P22)
3591   1              BIT_SET_ZERO(p2_data, 2);
3592   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FOURTH_BIT)) )// check P12(P23)
3593   1              BIT_SET_ZERO(p2_data, 3);
3594   1          GPIO_setOpenDrainOutput(1, 3);// P16
3595   1          GPIO_setPushPullupOutput(1, 4);//P17
3596   1          P0 = p0_data;
3597   1          P2 = p2_data;
3598   1          P3 = p3_data;
3599   1          P14 = 1;
3600   1      
3601   1      /***************************** P18 *************************************** */
3602   1          pos += 2;
3603   1          p0_data = USE_P0;
3604   1          p1_data = USE_P1;
3605   1          p2_data = USE_P2;
3606   1          p3_data = USE_P3;
3607   1          if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P1(P00)
3608   1              BIT_SET_ZERO(p0_data, 0);
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 67  

3609   1          if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P2(P01) value
3610   1              BIT_SET_ZERO(p0_data, 1);
3611   1          if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P3(P02)
3612   1              BIT_SET_ZERO(p0_data, 2);
3613   1          if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P4(P03)
3614   1              BIT_SET_ZERO(p0_data, 3);
3615   1          if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P5(P34)
3616   1              BIT_SET_ZERO(p3_data, 4);
3617   1          if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P6(P35)
3618   1              BIT_SET_ZERO(p3_data, 5);
3619   1          if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P7(P36)
3620   1              BIT_SET_ZERO(p3_data, 6);
3621   1          if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P8(P37)
3622   1              BIT_SET_ZERO(p3_data, 7);
3623   1      
3624   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SEVENTH_BIT)) )// check P9(P20)
3625   1              BIT_SET_ZERO(p2_data, 0);
3626   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SIXTH_BIT)) )// check P10(P21)
3627   1              BIT_SET_ZERO(p2_data, 1);
3628   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FIFTH_BIT)) )// check P11(P22)
3629   1              BIT_SET_ZERO(p2_data, 2);
3630   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FOURTH_BIT)) )// check P12(P23)
3631   1              BIT_SET_ZERO(p2_data, 3);
3632   1          GPIO_setOpenDrainOutput(1, 4);// P17
3633   1          GPIO_setPushPullupOutput(1, 5);//P18
3634   1          P0 = p0_data;
3635   1          P2 = p2_data;
3636   1          P3 = p3_data;
3637   1          P15 = 1;
3638   1      
3639   1      /***************************** P19 *************************************** */
3640   1          pos += 2;
3641   1          if ( bytes < MIN_BYTES )// Â≠óÁ¨¶Â≠óËäÇÊï∞‰∏çË∂≥, ÁªìÊùüËØ•Â≠óÊòæÁ§∫
3642   1              return;
3643   1          if ( pos >= arrLen )
3644   1          {
3645   2              bytePos++;
3646   2              pos = 0;
3647   2          }
3648   1          p0_data = USE_P0;
3649   1          p1_data = USE_P1;
3650   1          p2_data = USE_P2;
3651   1          p3_data = USE_P3;
3652   1          if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P1(P00)
3653   1              BIT_SET_ZERO(p0_data, 0);
3654   1          if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P2(P01) value
3655   1              BIT_SET_ZERO(p0_data, 1);
3656   1          if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P3(P02)
3657   1              BIT_SET_ZERO(p0_data, 2);
3658   1          if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P4(P03)
3659   1              BIT_SET_ZERO(p0_data, 3);
3660   1          if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P5(P34)
3661   1              BIT_SET_ZERO(p3_data, 4);
3662   1          if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P6(P35)
3663   1              BIT_SET_ZERO(p3_data, 5);
3664   1          if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P7(P36)
3665   1              BIT_SET_ZERO(p3_data, 6);
3666   1          if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P8(P37)
3667   1              BIT_SET_ZERO(p3_data, 7);
3668   1      
3669   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SEVENTH_BIT)) )// check P9(P20)
3670   1              BIT_SET_ZERO(p2_data, 0);
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 68  

3671   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SIXTH_BIT)) )// check P10(P21)
3672   1              BIT_SET_ZERO(p2_data, 1);
3673   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FIFTH_BIT)) )// check P11(P22)
3674   1              BIT_SET_ZERO(p2_data, 2);
3675   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FOURTH_BIT)) )// check P12(P23)
3676   1              BIT_SET_ZERO(p2_data, 3);
3677   1          GPIO_setOpenDrainOutput(1, 5);// P18
3678   1          GPIO_setPushPullupOutput(1, 6);//P19
3679   1          P0 = p0_data;
3680   1          P2 = p2_data;
3681   1          P3 = p3_data;
3682   1          P16 = 1;
3683   1      
3684   1      /***************************** P20 *************************************** */
3685   1          pos += 2;
3686   1          p0_data = USE_P0;
3687   1          p1_data = USE_P1;
3688   1          p2_data = USE_P2;
3689   1          p3_data = USE_P3;
3690   1          if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P1(P00)
3691   1              BIT_SET_ZERO(p0_data, 0);
3692   1          if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P2(P01) value
3693   1              BIT_SET_ZERO(p0_data, 1);
3694   1          if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P3(P02)
3695   1              BIT_SET_ZERO(p0_data, 2);
3696   1          if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P4(P03)
3697   1              BIT_SET_ZERO(p0_data, 3);
3698   1          if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P5(P34)
3699   1              BIT_SET_ZERO(p3_data, 4);
3700   1          if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P6(P35)
3701   1              BIT_SET_ZERO(p3_data, 5);
3702   1          if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P7(P36)
3703   1              BIT_SET_ZERO(p3_data, 6);
3704   1          if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P8(P37)
3705   1              BIT_SET_ZERO(p3_data, 7);
3706   1      
3707   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SEVENTH_BIT)) )// check P9(P20)
3708   1              BIT_SET_ZERO(p2_data, 0);
3709   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SIXTH_BIT)) )// check P10(P21)
3710   1              BIT_SET_ZERO(p2_data, 1);
3711   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FIFTH_BIT)) )// check P11(P22)
3712   1              BIT_SET_ZERO(p2_data, 2);
3713   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FOURTH_BIT)) )// check P12(P23)
3714   1              BIT_SET_ZERO(p2_data, 3);
3715   1          GPIO_setOpenDrainOutput(1, 6);// P19
3716   1          GPIO_setPushPullupOutput(1, 7);//P20
3717   1          P0 = p0_data;
3718   1          P2 = p2_data;
3719   1          P3 = p3_data;
3720   1          P17 = 1;
3721   1      
3722   1      /***************************** P21 *************************************** */
3723   1          pos += 2;
3724   1          p0_data = USE_P0;
3725   1          p1_data = USE_P1;
3726   1          p2_data = USE_P2;
3727   1          p3_data = USE_P3;
3728   1          if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P1(P00)
3729   1              BIT_SET_ZERO(p0_data, 0);
3730   1          if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P2(P01) value
3731   1              BIT_SET_ZERO(p0_data, 1);
3732   1          if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P3(P02)
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 69  

3733   1              BIT_SET_ZERO(p0_data, 2);
3734   1          if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P4(P03)
3735   1              BIT_SET_ZERO(p0_data, 3);
3736   1          if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P5(P34)
3737   1              BIT_SET_ZERO(p3_data, 4);
3738   1          if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P6(P35)
3739   1              BIT_SET_ZERO(p3_data, 5);
3740   1          if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P7(P36)
3741   1              BIT_SET_ZERO(p3_data, 6);
3742   1          if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P8(P37)
3743   1              BIT_SET_ZERO(p3_data, 7);
3744   1      
3745   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SEVENTH_BIT)) )// check P9(P20)
3746   1              BIT_SET_ZERO(p2_data, 0);
3747   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SIXTH_BIT)) )// check P10(P21)
3748   1              BIT_SET_ZERO(p2_data, 1);
3749   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FIFTH_BIT)) )// check P11(P22)
3750   1              BIT_SET_ZERO(p2_data, 2);
3751   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FOURTH_BIT)) )// check P12(P23)
3752   1              BIT_SET_ZERO(p2_data, 3);
3753   1          GPIO_setOpenDrainOutput(1, 7);// P20
3754   1          GPIO_setPushPullupOutput(2, 4);//P21
3755   1          P0 = p0_data;
3756   1          P2 = p2_data;
3757   1          P3 = p3_data;
3758   1          P24 = 1;
3759   1      
3760   1      /***************************** P22 *************************************** */
3761   1          pos += 2;
3762   1          p0_data = USE_P0;
3763   1          p1_data = USE_P1;
3764   1          p2_data = USE_P2;
3765   1          p3_data = USE_P3;
3766   1          if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P1(P00)
3767   1              BIT_SET_ZERO(p0_data, 0);
3768   1          if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P2(P01) value
3769   1              BIT_SET_ZERO(p0_data, 1);
3770   1          if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P3(P02)
3771   1              BIT_SET_ZERO(p0_data, 2);
3772   1          if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P4(P03)
3773   1              BIT_SET_ZERO(p0_data, 3);
3774   1          if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P5(P34)
3775   1              BIT_SET_ZERO(p3_data, 4);
3776   1          if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P6(P35)
3777   1              BIT_SET_ZERO(p3_data, 5);
3778   1          if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P7(P36)
3779   1              BIT_SET_ZERO(p3_data, 6);
3780   1          if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P8(P37)
3781   1              BIT_SET_ZERO(p3_data, 7);
3782   1      
3783   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SEVENTH_BIT)) )// check P9(P20)
3784   1              BIT_SET_ZERO(p2_data, 0);
3785   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SIXTH_BIT)) )// check P10(P21)
3786   1              BIT_SET_ZERO(p2_data, 1);
3787   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FIFTH_BIT)) )// check P11(P22)
3788   1              BIT_SET_ZERO(p2_data, 2);
3789   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FOURTH_BIT)) )// check P12(P23)
3790   1              BIT_SET_ZERO(p2_data, 3);
3791   1          GPIO_setOpenDrainOutput(2, 4);// P21
3792   1          GPIO_setPushPullupOutput(2, 5);//P22
3793   1          P0 = p0_data;
3794   1          P2 = p2_data;
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 70  

3795   1          P3 = p3_data;
3796   1          P25 = 1;
3797   1      
3798   1      /***************************** P23 *************************************** */
3799   1          pos += 2;
3800   1          p0_data = USE_P0;
3801   1          p1_data = USE_P1;
3802   1          p2_data = USE_P2;
3803   1          p3_data = USE_P3;
3804   1          if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P1(P00)
3805   1              BIT_SET_ZERO(p0_data, 0);
3806   1          if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P2(P01) value
3807   1              BIT_SET_ZERO(p0_data, 1);
3808   1          if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P3(P02)
3809   1              BIT_SET_ZERO(p0_data, 2);
3810   1          if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P4(P03)
3811   1              BIT_SET_ZERO(p0_data, 3);
3812   1          if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P5(P34)
3813   1              BIT_SET_ZERO(p3_data, 4);
3814   1          if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P6(P35)
3815   1              BIT_SET_ZERO(p3_data, 5);
3816   1          if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P7(P36)
3817   1              BIT_SET_ZERO(p3_data, 6);
3818   1          if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P8(P37)
3819   1              BIT_SET_ZERO(p3_data, 7);
3820   1      
3821   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SEVENTH_BIT)) )// check P9(P20)
3822   1              BIT_SET_ZERO(p2_data, 0);
3823   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SIXTH_BIT)) )// check P10(P21)
3824   1              BIT_SET_ZERO(p2_data, 1);
3825   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FIFTH_BIT)) )// check P11(P22)
3826   1              BIT_SET_ZERO(p2_data, 2);
3827   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FOURTH_BIT)) )// check P12(P23)
3828   1              BIT_SET_ZERO(p2_data, 3);
3829   1          GPIO_setOpenDrainOutput(2, 5);// P22
3830   1          GPIO_setPushPullupOutput(2, 6);//P23
3831   1          P0 = p0_data;
3832   1          P2 = p2_data;
3833   1          P3 = p3_data;
3834   1          P26 = 1;
3835   1      
3836   1      /***************************** P24 *************************************** */
3837   1          pos += 2;
3838   1          p0_data = USE_P0;
3839   1          p1_data = USE_P1;
3840   1          p2_data = USE_P2;
3841   1          p3_data = USE_P3;
3842   1          if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P1(P00)
3843   1              BIT_SET_ZERO(p0_data, 0);
3844   1          if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P2(P01) value
3845   1              BIT_SET_ZERO(p0_data, 1);
3846   1          if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P3(P02)
3847   1              BIT_SET_ZERO(p0_data, 2);
3848   1          if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P4(P03)
3849   1              BIT_SET_ZERO(p0_data, 3);
3850   1          if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P5(P34)
3851   1              BIT_SET_ZERO(p3_data, 4);
3852   1          if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P6(P35)
3853   1              BIT_SET_ZERO(p3_data, 5);
3854   1          if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P7(P36)
3855   1              BIT_SET_ZERO(p3_data, 6);
3856   1          if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P8(P37)
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 71  

3857   1              BIT_SET_ZERO(p3_data, 7);
3858   1      
3859   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SEVENTH_BIT)) )// check P9(P20)
3860   1              BIT_SET_ZERO(p2_data, 0);
3861   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SIXTH_BIT)) )// check P10(P21)
3862   1              BIT_SET_ZERO(p2_data, 1);
3863   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FIFTH_BIT)) )// check P11(P22)
3864   1              BIT_SET_ZERO(p2_data, 2);
3865   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FOURTH_BIT)) )// check P12(P23)
3866   1              BIT_SET_ZERO(p2_data, 3);
3867   1          GPIO_setOpenDrainOutput(2, 6);// P23
3868   1          GPIO_setPushPullupOutput(2, 7);//P24
3869   1          P0 = p0_data;
3870   1          P2 = p2_data;
3871   1          P3 = p3_data;
3872   1          P27 = 1;
3873   1      
3874   1          GPIO_setOpenDrainOutput(2, 7);// P24
3875   1          P2 = ~(USE_P2 >> 4);// P2.0~P2.3
3876   1      
3877   1          return;
3878   1      }
3879          
3880          /// @brief LEDÁÇπÈòµ3ÊòæÁ§∫
3881          /// @param strData ÊñáÂ≠óÊòæÁ§∫Á†Å([2][12])
3882          /// @param bytes ËØ•ÊñáÂ≠óÊâÄÂç†Â≠óËäÇ‰Ωç
3883          /// @param arrLen ÊòæÁ§∫Á†ÅÈïøÂ∫¶
3884          void LED_screen3_test(const unsigned char(*strData)[12],
3885                                const unsigned char bytes,
3886                                const unsigned char arrLen)
3887          {
3888   1          unsigned char p0_data = USE_P0,
3889   1              p1_data = USE_P1,
3890   1              p2_data = USE_P2,
3891   1              p3_data = USE_P3,
3892   1              pos = 0x00,
3893   1              bytePos = 0x00;
3894   1          P0 = p0_data;
3895   1          P1 = p1_data;
3896   1          P2 = p2_data;
3897   1          P3 = p3_data;
3898   1          if ( arrLen < MIN_ARR_LEN || strData == NULL )// ËæìÂÖ•ÊòæÁ§∫Á†ÅÈïøÂ∫¶‰∏çË∂≥ÊàñÊåáÈíà‰∏∫Á©∫
3899   1              return;
3900   1      
3901   1      /***************************** P13 *************************************** */
3902   1          if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P0(P33)
3903   1              BIT_SET_ZERO(p3_data, 3);
3904   1          if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P14(P11)
3905   1              BIT_SET_ZERO(p1_data, 1);
3906   1          if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P15(P12)
3907   1              BIT_SET_ZERO(p1_data, 2);
3908   1          if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P16(P13)
3909   1              BIT_SET_ZERO(p1_data, 3);
3910   1          if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P17(P14)
3911   1              BIT_SET_ZERO(p1_data, 4);
3912   1          if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P18(P15)
3913   1              BIT_SET_ZERO(p1_data, 5);
3914   1          if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P19(P16)
3915   1              BIT_SET_ZERO(p1_data, 6);
3916   1          if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P20(P17)
3917   1              BIT_SET_ZERO(p1_data, 7);
3918   1      
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 72  

3919   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SEVENTH_BIT)) )// check P21(P24)
3920   1              BIT_SET_ZERO(p2_data, 4);
3921   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SIXTH_BIT)) )// check P22(P25)
3922   1              BIT_SET_ZERO(p2_data, 5);
3923   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FIFTH_BIT)) )// check P23(P26)
3924   1              BIT_SET_ZERO(p2_data, 6);
3925   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FOURTH_BIT)) )// check P24(P27)
3926   1              BIT_SET_ZERO(p2_data, 7);
3927   1          GPIO_setOpenDrainOutput(2, 3);// P12
3928   1          GPIO_setPushPullupOutput(1, 0);//P13
3929   1          P3 = p3_data;
3930   1          P2 = p2_data;
3931   1          P1 = p1_data;
3932   1          P10 = 1;
3933   1      
3934   1      /***************************** P14 *************************************** */
3935   1          pos += 2;
3936   1          p0_data = USE_P0;
3937   1          p1_data = USE_P1;
3938   1          p2_data = USE_P2;
3939   1          p3_data = USE_P3;
3940   1          if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P13(P10)
3941   1              BIT_SET_ZERO(p1_data, 0);
3942   1          if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P0(P33)
3943   1              BIT_SET_ZERO(p3_data, 3);
3944   1          if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P15(P12)
3945   1              BIT_SET_ZERO(p1_data, 2);
3946   1          if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P16(P13)
3947   1              BIT_SET_ZERO(p1_data, 3);
3948   1          if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P17(P14)
3949   1              BIT_SET_ZERO(p1_data, 4);
3950   1          if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P18(P15)
3951   1              BIT_SET_ZERO(p1_data, 5);
3952   1          if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P19(P16)
3953   1              BIT_SET_ZERO(p1_data, 6);
3954   1          if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P20(P17)
3955   1              BIT_SET_ZERO(p1_data, 7);
3956   1      
3957   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SEVENTH_BIT)) )// check P21(P24)
3958   1              BIT_SET_ZERO(p2_data, 4);
3959   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SIXTH_BIT)) )// check P22(P25)
3960   1              BIT_SET_ZERO(p2_data, 5);
3961   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FIFTH_BIT)) )// check P23(P26)
3962   1              BIT_SET_ZERO(p2_data, 6);
3963   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FOURTH_BIT)) )// check P24(P27)
3964   1              BIT_SET_ZERO(p2_data, 7);
3965   1          GPIO_setOpenDrainOutput(1, 0);// P13
3966   1          GPIO_setPushPullupOutput(1, 1);//P14
3967   1          P3 = p3_data;
3968   1          P2 = p2_data;
3969   1          P1 = p1_data;
3970   1          P11 = 1;
3971   1      
3972   1      /***************************** P15 *************************************** */
3973   1          pos += 2;
3974   1          p0_data = USE_P0;
3975   1          p1_data = USE_P1;
3976   1          p2_data = USE_P2;
3977   1          p3_data = USE_P3;
3978   1          if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P13(P10)
3979   1              BIT_SET_ZERO(p1_data, 0);
3980   1          if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P14(P11)
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 73  

3981   1              BIT_SET_ZERO(p1_data, 1);
3982   1          if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P0(P33)
3983   1              BIT_SET_ZERO(p3_data, 3);
3984   1          if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P16(P13)
3985   1              BIT_SET_ZERO(p1_data, 3);
3986   1          if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P17(P14)
3987   1              BIT_SET_ZERO(p1_data, 4);
3988   1          if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P18(P15)
3989   1              BIT_SET_ZERO(p1_data, 5);
3990   1          if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P19(P16)
3991   1              BIT_SET_ZERO(p1_data, 6);
3992   1          if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P20(P17)
3993   1              BIT_SET_ZERO(p1_data, 7);
3994   1      
3995   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SEVENTH_BIT)) )// check P21(P24)
3996   1              BIT_SET_ZERO(p2_data, 4);
3997   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SIXTH_BIT)) )// check P22(P25)
3998   1              BIT_SET_ZERO(p2_data, 5);
3999   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FIFTH_BIT)) )// check P23(P26)
4000   1              BIT_SET_ZERO(p2_data, 6);
4001   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FOURTH_BIT)) )// check P24(P27)
4002   1              BIT_SET_ZERO(p2_data, 7);
4003   1          GPIO_setOpenDrainOutput(1, 1);// P14
4004   1          GPIO_setPushPullupOutput(1, 2);//P15
4005   1          P3 = p3_data;
4006   1          P2 = p2_data;
4007   1          P1 = p1_data;
4008   1          P12 = 1;
4009   1      
4010   1      /***************************** P16 *************************************** */
4011   1          pos += 2;
4012   1          p0_data = USE_P0;
4013   1          p1_data = USE_P1;
4014   1          p2_data = USE_P2;
4015   1          p3_data = USE_P3;
4016   1          if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P13(P10)
4017   1              BIT_SET_ZERO(p1_data, 0);
4018   1          if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P14(P11)
4019   1              BIT_SET_ZERO(p1_data, 1);
4020   1          if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P15(P12)
4021   1              BIT_SET_ZERO(p1_data, 2);
4022   1          if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P0(P33)
4023   1              BIT_SET_ZERO(p3_data, 3);
4024   1          if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P17(P14)
4025   1              BIT_SET_ZERO(p1_data, 4);
4026   1          if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P18(P15)
4027   1              BIT_SET_ZERO(p1_data, 5);
4028   1          if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P19(P16)
4029   1              BIT_SET_ZERO(p1_data, 6);
4030   1          if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P20(P17)
4031   1              BIT_SET_ZERO(p1_data, 7);
4032   1      
4033   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SEVENTH_BIT)) )// check P21(P24)
4034   1              BIT_SET_ZERO(p2_data, 4);
4035   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SIXTH_BIT)) )// check P22(P25)
4036   1              BIT_SET_ZERO(p2_data, 5);
4037   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FIFTH_BIT)) )// check P23(P26)
4038   1              BIT_SET_ZERO(p2_data, 6);
4039   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FOURTH_BIT)) )// check P24(P27)
4040   1              BIT_SET_ZERO(p2_data, 7);
4041   1          GPIO_setOpenDrainOutput(1, 2);// P15
4042   1          GPIO_setPushPullupOutput(1, 3);//P16
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 74  

4043   1          P3 = p3_data;
4044   1          P2 = p2_data;
4045   1          P1 = p1_data;
4046   1          P13 = 1;
4047   1      
4048   1      /***************************** P17 *************************************** */
4049   1          pos += 2;
4050   1          p0_data = USE_P0;
4051   1          p1_data = USE_P1;
4052   1          p2_data = USE_P2;
4053   1          p3_data = USE_P3;
4054   1          if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P13(P10)
4055   1              BIT_SET_ZERO(p1_data, 0);
4056   1          if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P14(P11)
4057   1              BIT_SET_ZERO(p1_data, 1);
4058   1          if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P15(P12)
4059   1              BIT_SET_ZERO(p1_data, 2);
4060   1          if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P16(P13)
4061   1              BIT_SET_ZERO(p1_data, 3);
4062   1          if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P0(P33)
4063   1              BIT_SET_ZERO(p3_data, 3);
4064   1          if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P18(P15)
4065   1              BIT_SET_ZERO(p1_data, 5);
4066   1          if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P19(P16)
4067   1              BIT_SET_ZERO(p1_data, 6);
4068   1          if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P20(P17)
4069   1              BIT_SET_ZERO(p1_data, 7);
4070   1      
4071   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SEVENTH_BIT)) )// check P21(P24)
4072   1              BIT_SET_ZERO(p2_data, 4);
4073   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SIXTH_BIT)) )// check P22(P25)
4074   1              BIT_SET_ZERO(p2_data, 5);
4075   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FIFTH_BIT)) )// check P23(P26)
4076   1              BIT_SET_ZERO(p2_data, 6);
4077   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FOURTH_BIT)) )// check P24(P27)
4078   1              BIT_SET_ZERO(p2_data, 7);
4079   1          GPIO_setOpenDrainOutput(1, 3);// P16
4080   1          GPIO_setPushPullupOutput(1, 4);//P17
4081   1          P3 = p3_data;
4082   1          P2 = p2_data;
4083   1          P1 = p1_data;
4084   1          P14 = 1;
4085   1      
4086   1      /***************************** P18 *************************************** */
4087   1          pos += 2;
4088   1          p0_data = USE_P0;
4089   1          p1_data = USE_P1;
4090   1          p2_data = USE_P2;
4091   1          p3_data = USE_P3;
4092   1          if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P13(P10)
4093   1              BIT_SET_ZERO(p1_data, 0);
4094   1          if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P14(P11)
4095   1              BIT_SET_ZERO(p1_data, 1);
4096   1          if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P15(P12)
4097   1              BIT_SET_ZERO(p1_data, 2);
4098   1          if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P16(P13)
4099   1              BIT_SET_ZERO(p1_data, 3);
4100   1          if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P17(P14)
4101   1              BIT_SET_ZERO(p1_data, 4);
4102   1          if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P0(P33)
4103   1              BIT_SET_ZERO(p3_data, 3);
4104   1          if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P19(P16)
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 75  

4105   1              BIT_SET_ZERO(p1_data, 6);
4106   1          if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P20(P17)
4107   1              BIT_SET_ZERO(p1_data, 7);
4108   1      
4109   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SEVENTH_BIT)) )// check P21(P24)
4110   1              BIT_SET_ZERO(p2_data, 4);
4111   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SIXTH_BIT)) )// check P22(P25)
4112   1              BIT_SET_ZERO(p2_data, 5);
4113   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FIFTH_BIT)) )// check P23(P26)
4114   1              BIT_SET_ZERO(p2_data, 6);
4115   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FOURTH_BIT)) )// check P24(P27)
4116   1              BIT_SET_ZERO(p2_data, 7);
4117   1          GPIO_setOpenDrainOutput(1, 4);// P17
4118   1          GPIO_setPushPullupOutput(1, 5);//P18
4119   1          P3 = p3_data;
4120   1          P2 = p2_data;
4121   1          P1 = p1_data;
4122   1          P15 = 1;
4123   1      
4124   1      /***************************** P19 *************************************** */
4125   1          pos += 2;
4126   1          if ( bytes < MIN_BYTES )// Â≠óÁ¨¶Â≠óËäÇÊï∞‰∏çË∂≥, ÁªìÊùüËØ•Â≠óÊòæÁ§∫
4127   1              return;
4128   1          if ( pos >= arrLen )
4129   1          {
4130   2              bytePos++;
4131   2              pos = 0;
4132   2          }
4133   1          p0_data = USE_P0;
4134   1          p1_data = USE_P1;
4135   1          p2_data = USE_P2;
4136   1          p3_data = USE_P3;
4137   1          if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P13(P10)
4138   1              BIT_SET_ZERO(p1_data, 0);
4139   1          if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P14(P11)
4140   1              BIT_SET_ZERO(p1_data, 1);
4141   1          if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P15(P12)
4142   1              BIT_SET_ZERO(p1_data, 2);
4143   1          if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P16(P13)
4144   1              BIT_SET_ZERO(p1_data, 3);
4145   1          if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P17(P14)
4146   1              BIT_SET_ZERO(p1_data, 4);
4147   1          if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P18(P15)
4148   1              BIT_SET_ZERO(p1_data, 5);
4149   1          if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P0(P33)
4150   1              BIT_SET_ZERO(p3_data, 3);
4151   1          if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P20(P17)
4152   1              BIT_SET_ZERO(p1_data, 7);
4153   1      
4154   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SEVENTH_BIT)) )// check P21(P24)
4155   1              BIT_SET_ZERO(p2_data, 4);
4156   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SIXTH_BIT)) )// check P22(P25)
4157   1              BIT_SET_ZERO(p2_data, 5);
4158   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FIFTH_BIT)) )// check P23(P26)
4159   1              BIT_SET_ZERO(p2_data, 6);
4160   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FOURTH_BIT)) )// check P24(P27)
4161   1              BIT_SET_ZERO(p2_data, 7);
4162   1          GPIO_setOpenDrainOutput(1, 5);// P18
4163   1          GPIO_setPushPullupOutput(1, 6);//P19
4164   1          P3 = p3_data;
4165   1          P2 = p2_data;
4166   1          P1 = p1_data;
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 76  

4167   1          P16 = 1;
4168   1      
4169   1      /***************************** P20 *************************************** */
4170   1          pos += 2;
4171   1          p0_data = USE_P0;
4172   1          p1_data = USE_P1;
4173   1          p2_data = USE_P2;
4174   1          p3_data = USE_P3;
4175   1          if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P13(P10)
4176   1              BIT_SET_ZERO(p1_data, 0);
4177   1          if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P14(P11)
4178   1              BIT_SET_ZERO(p1_data, 1);
4179   1          if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P15(P12)
4180   1              BIT_SET_ZERO(p1_data, 2);
4181   1          if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P16(P13)
4182   1              BIT_SET_ZERO(p1_data, 3);
4183   1          if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P17(P14)
4184   1              BIT_SET_ZERO(p1_data, 4);
4185   1          if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P18(P15)
4186   1              BIT_SET_ZERO(p1_data, 5);
4187   1          if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P19(P16)
4188   1              BIT_SET_ZERO(p1_data, 6);
4189   1          if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P0(P33)
4190   1              BIT_SET_ZERO(p3_data, 3);
4191   1      
4192   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SEVENTH_BIT)) )// check P21(P24)
4193   1              BIT_SET_ZERO(p2_data, 4);
4194   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SIXTH_BIT)) )// check P22(P25)
4195   1              BIT_SET_ZERO(p2_data, 5);
4196   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FIFTH_BIT)) )// check P23(P26)
4197   1              BIT_SET_ZERO(p2_data, 6);
4198   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FOURTH_BIT)) )// check P24(P27)
4199   1              BIT_SET_ZERO(p2_data, 7);
4200   1          GPIO_setOpenDrainOutput(1, 6);// P19
4201   1          GPIO_setPushPullupOutput(1, 7);//P20
4202   1          P3 = p3_data;
4203   1          P2 = p2_data;
4204   1          P1 = p1_data;
4205   1          P17 = 1;
4206   1      
4207   1      /***************************** P21 *************************************** */
4208   1          pos += 2;
4209   1          p0_data = USE_P0;
4210   1          p1_data = USE_P1;
4211   1          p2_data = USE_P2;
4212   1          p3_data = USE_P3;
4213   1          if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P13(P10)
4214   1              BIT_SET_ZERO(p1_data, 0);
4215   1          if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P14(P11)
4216   1              BIT_SET_ZERO(p1_data, 1);
4217   1          if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P15(P12)
4218   1              BIT_SET_ZERO(p1_data, 2);
4219   1          if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P16(P13)
4220   1              BIT_SET_ZERO(p1_data, 3);
4221   1          if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P17(P14)
4222   1              BIT_SET_ZERO(p1_data, 4);
4223   1          if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P18(P15)
4224   1              BIT_SET_ZERO(p1_data, 5);
4225   1          if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P19(P16)
4226   1              BIT_SET_ZERO(p1_data, 6);
4227   1          if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P20(P17)
4228   1              BIT_SET_ZERO(p1_data, 7);
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 77  

4229   1      
4230   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SEVENTH_BIT)) )// check P20(P33)
4231   1              BIT_SET_ZERO(p3_data, 3);
4232   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SIXTH_BIT)) )// check P22(P25)
4233   1              BIT_SET_ZERO(p2_data, 5);
4234   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FIFTH_BIT)) )// check P23(P26)
4235   1              BIT_SET_ZERO(p2_data, 6);
4236   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FOURTH_BIT)) )// check P24(P27)
4237   1              BIT_SET_ZERO(p2_data, 7);
4238   1          GPIO_setOpenDrainOutput(1, 7);// P20
4239   1          GPIO_setPushPullupOutput(2, 4);//P21
4240   1          P3 = p3_data;
4241   1          P2 = p2_data;
4242   1          P1 = p1_data;
4243   1          P24 = 1;
4244   1      
4245   1      /***************************** P22 *************************************** */
4246   1          pos += 2;
4247   1          p0_data = USE_P0;
4248   1          p1_data = USE_P1;
4249   1          p2_data = USE_P2;
4250   1          p3_data = USE_P3;
4251   1          if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P13(P10)
4252   1              BIT_SET_ZERO(p1_data, 0);
4253   1          if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P14(P11)
4254   1              BIT_SET_ZERO(p1_data, 1);
4255   1          if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P15(P12)
4256   1              BIT_SET_ZERO(p1_data, 2);
4257   1          if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P16(P13)
4258   1              BIT_SET_ZERO(p1_data, 3);
4259   1          if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P17(P14)
4260   1              BIT_SET_ZERO(p1_data, 4);
4261   1          if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P18(P15)
4262   1              BIT_SET_ZERO(p1_data, 5);
4263   1          if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P19(P16)
4264   1              BIT_SET_ZERO(p1_data, 6);
4265   1          if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P20(P17)
4266   1              BIT_SET_ZERO(p1_data, 7);
4267   1      
4268   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SEVENTH_BIT)) )// check P21(P24)
4269   1              BIT_SET_ZERO(p2_data, 4);
4270   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SIXTH_BIT)) )// check P0(P33)
4271   1              BIT_SET_ZERO(p3_data, 3);
4272   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FIFTH_BIT)) )// check P23(P26)
4273   1              BIT_SET_ZERO(p2_data, 6);
4274   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FOURTH_BIT)) )// check P24(P27)
4275   1              BIT_SET_ZERO(p2_data, 7);
4276   1          GPIO_setOpenDrainOutput(2, 4);// P21
4277   1          GPIO_setPushPullupOutput(2, 5);//P22
4278   1          P3 = p3_data;
4279   1          P2 = p2_data;
4280   1          P1 = p1_data;
4281   1          P25 = 1;
4282   1      
4283   1      /***************************** P23 *************************************** */
4284   1          pos += 2;
4285   1          p0_data = USE_P0;
4286   1          p1_data = USE_P1;
4287   1          p2_data = USE_P2;
4288   1          p3_data = USE_P3;
4289   1          if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P13(P10)
4290   1              BIT_SET_ZERO(p1_data, 0);
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 78  

4291   1          if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P14(P11)
4292   1              BIT_SET_ZERO(p1_data, 1);
4293   1          if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P15(P12)
4294   1              BIT_SET_ZERO(p1_data, 2);
4295   1          if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P16(P13)
4296   1              BIT_SET_ZERO(p1_data, 3);
4297   1          if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P17(P14)
4298   1              BIT_SET_ZERO(p1_data, 4);
4299   1          if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P18(P15)
4300   1              BIT_SET_ZERO(p1_data, 5);
4301   1          if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P19(P16)
4302   1              BIT_SET_ZERO(p1_data, 6);
4303   1          if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P20(P17)
4304   1              BIT_SET_ZERO(p1_data, 7);
4305   1      
4306   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SEVENTH_BIT)) )// check P21(P24)
4307   1              BIT_SET_ZERO(p2_data, 4);
4308   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SIXTH_BIT)) )// check P22(P25)
4309   1              BIT_SET_ZERO(p2_data, 5);
4310   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FIFTH_BIT)) )// check P0(P33)
4311   1              BIT_SET_ZERO(p3_data, 3);
4312   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FOURTH_BIT)) )// check P24(P27)
4313   1              BIT_SET_ZERO(p2_data, 7);
4314   1          GPIO_setOpenDrainOutput(2, 5);// P22
4315   1          GPIO_setPushPullupOutput(2, 6);//P23
4316   1          P3 = p3_data;
4317   1          P2 = p2_data;
4318   1          P1 = p1_data;
4319   1          P26 = 1;
4320   1      
4321   1      /***************************** P24 *************************************** */
4322   1          pos += 2;
4323   1          p0_data = USE_P0;
4324   1          p1_data = USE_P1;
4325   1          p2_data = USE_P2;
4326   1          p3_data = USE_P3;
4327   1          if ( (FIND_BIT(strData[bytePos][pos], SEVENTH_BIT)) )// check P13(P10)
4328   1              BIT_SET_ZERO(p1_data, 0);
4329   1          if ( (FIND_BIT(strData[bytePos][pos], SIXTH_BIT)) )// check P14(P11)
4330   1              BIT_SET_ZERO(p1_data, 1);
4331   1          if ( (FIND_BIT(strData[bytePos][pos], FIFTH_BIT)) )// check P15(P12)
4332   1              BIT_SET_ZERO(p1_data, 2);
4333   1          if ( (FIND_BIT(strData[bytePos][pos], FOURTH_BIT)) )// check P16(P13)
4334   1              BIT_SET_ZERO(p1_data, 3);
4335   1          if ( (FIND_BIT(strData[bytePos][pos], THIRD_BIT)) )// check P17(P14)
4336   1              BIT_SET_ZERO(p1_data, 4);
4337   1          if ( (FIND_BIT(strData[bytePos][pos], SECOND_BIT)) )// check P18(P15)
4338   1              BIT_SET_ZERO(p1_data, 5);
4339   1          if ( (FIND_BIT(strData[bytePos][pos], FIRST_BIT)) )// check P19(P16)
4340   1              BIT_SET_ZERO(p1_data, 6);
4341   1          if ( (FIND_BIT(strData[bytePos][pos], ZEROTH_BIT)) )// check P20(P17)
4342   1              BIT_SET_ZERO(p1_data, 7);
4343   1      
4344   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SEVENTH_BIT)) )// check P21(P24)
4345   1              BIT_SET_ZERO(p2_data, 4);
4346   1          if ( (FIND_BIT(strData[bytePos][pos + 1], SIXTH_BIT)) )// check P22(P25)
4347   1              BIT_SET_ZERO(p2_data, 5);
4348   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FIFTH_BIT)) )// check P23(P26)
4349   1              BIT_SET_ZERO(p2_data, 6);
4350   1          if ( (FIND_BIT(strData[bytePos][pos + 1], FOURTH_BIT)) )// check P0(P33)
4351   1              BIT_SET_ZERO(p3_data, 3);
4352   1          GPIO_setOpenDrainOutput(2, 6);// P23
C51 COMPILER V9.00   GPIO_INIT                                                             08/19/2024 08:55:07 PAGE 79  

4353   1          GPIO_setPushPullupOutput(2, 7);//P24
4354   1          P3 = p3_data;
4355   1          P2 = p2_data;
4356   1          P1 = p1_data;
4357   1          P27 = 1;
4358   1      
4359   1          GPIO_setOpenDrainOutput(2, 7);
4360   1          P27 = 0;
4361   1          return;
4362   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  17707    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =     18      47
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
